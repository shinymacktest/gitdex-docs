---
title: "User Interface Components"
description: "Documentation for reusable UI components, their props, and usage across the application."
sidebar_position: 31
---
 # User Interface Components

This section provides an in-depth look into the core reusable UI components that form the foundation of the application's user interface. These components are designed to be modular, maintainable, and to encapsulate specific functionalities, ensuring a consistent user experience across the platform.

Each component's documentation will cover its purpose, key features, prop definitions (where applicable), and relevant code snippets to illustrate its implementation and usage patterns.

## ChatContainer Component

The `ChatContainer` component is the central hub for displaying messages within a chat conversation. It dynamically renders messages exchanged between the authenticated user and a selected friend, handles message loading states, and ensures the chat view scrolls to the latest message.

### Features

*   **Dynamic Message Display**: Renders individual chat messages, distinguishing between messages sent by the authenticated user and the selected friend.
*   **Loading State Management**: Shows a skeleton loader while messages are being fetched.
*   **Real-time Updates**: Subscribes to real-time message updates to display new messages instantly.
*   **Auto-Scroll**: Automatically scrolls to the bottom of the chat view when new messages arrive or the component first loads.
*   **Integration with `ChatHeader` and `MessageInput`**: Composes the chat interface by including these sub-components.

### Key Usage

The `ChatContainer` relies on the `useChatStore` and `useAuthStore` Zustand hooks to manage chat-related state (messages, selected user, loading status) and authentication details, respectively.

```jsx
// frontend/src/components/ChatContainer.jsx
import { useEffect, useRef } from "react";
import { useChatStore } from "../store/useChatStore";
import { useAuthStore } from "../store/useAuthStore";
// ... other imports

const ChatContainer = () => {
    const { messages, getMessages, isMessagesLoading, selectedUser, subscribeToMessages, unsubscribeFromMessages } =
        useChatStore();
    const { authUser } = useAuthStore();
    const messageEndRef = useRef(null);

    useEffect(() => {
        getMessages(selectedUser._id);
        subscribeToMessages();
        return () => unsubscribeFromMessages();
    }, [selectedUser._id, getMessages, subscribeToMessages, unsubscribeFromMessages]);

    useEffect(() => {
        if(messageEndRef.current && messages){
            messageEndRef.current.scrollIntoView({behaviour : "smooth"})
        }
    }, [messages])

    // ... rendering logic
};

export default ChatContainer;
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/ChatContainer.jsx#L6-L23)

The `useEffect` hook on lines 15-20 handles fetching messages for the `selectedUser` and setting up real-time message subscriptions. The cleanup function ensures that subscriptions are properly unsubscribed when the component unmounts or the `selectedUser` changes, preventing memory leaks. The second `useEffect` on lines 22-26 ensures that the chat view always scrolls to the latest message.

### ChatContainer Message Flow

The following sequence diagram illustrates the lifecycle of message fetching and display within the `ChatContainer`.





```mermaid
sequenceDiagram
    participant C as "ChatContainer"
    participant CS as "useChatStore"
    participant AU as "useAuthStore"
    participant S as "Backend Server"
    participant WS as "WebSocket Server"

    C->>+CS: "getMessages(selectedUser._id)"
    CS->>+S: "GET /api/messages/:id"
    S->>-CS: "Message Data"
    CS->>-C: "Update messages, isMessagesLoading = false"

    C->>+CS: "subscribeToMessages()"
    CS->>+WS: "Establish WebSocket Connection"
    WS->>C: "Receive Existing Message (Optional)"
    Note right of WS: "Initial message from server on connection if any"
    C->>+CS: "Handle new message from WS"
    CS->>-C: "Update messages state"

    C->>C: "Scroll to messageEndRef"
    C->>AU: "authUser data for sender comparison"
    C->>C: "Render messages (sent/received)"

    C->>-CS: "Component Unmount / selectedUser change"
    CS->>-WS: "unsubscribeFromMessages()"
```



## MessageInput Component

The `MessageInput` component provides the interface for users to compose and send messages, including text and optional image attachments. It handles input state, image preview, and interaction with the chat store to send messages.

### Features

*   **Text Input**: Allows users to type text messages.
*   **Image Attachment**: Supports attaching image files with a preview feature.
*   **Image Preview & Removal**: Displays a preview of the attached image and allows users to remove it before sending.
*   **Message Sending Logic**: Integrates with `useChatStore` to dispatch messages to the backend.
*   **Input Validation**: Ensures that either text or an image is present before allowing a message to be sent.

### Key Usage

The component manages local state for the message text and image preview. It interacts with the `sendMessage` function provided by `useChatStore` to send the composed message.

```jsx
// frontend/src/components/MessageInput.jsx
import { useRef, useState } from "react";
import { useChatStore } from "../store/useChatStore";
import { Image, Send, X } from "lucide-react";
import toast from "react-hot-toast";

const MessageInput = () => {
    const [text, setText] = useState("");
    const [imagePreview, setImagePreview] = useState(null);
    const fileInputRef = useRef(null);
    const { sendMessage } = useChatStore();

    // ... handleImageChange, removeImage functions

    const handleSendMessage = async (e) => {
        e.preventDefault();
        if (!text.trim() && !imagePreview) return; // Prevent sending empty messages

        try {
            await sendMessage({ text: text.trim(), image: imagePreview });
            setText("");
            setImagePreview(null);
            if (fileInputRef.current) fileInputRef.current = ""; // Clear file input
        } catch (error) {
            console.error("Failed to send message", error);
        }
    };

    return (
        // ... JSX for input, image preview, and send button
    );
};

export default MessageInput;
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/MessageInput.jsx#L7-L38)

The `handleSendMessage` function (lines 28-38) is crucial. It prevents sending empty messages, calls the `sendMessage` action from `useChatStore`, and then resets the input fields and image preview upon successful submission. The `fileInputRef` is used to programmatically clear the file input field.

## Navbar Component

The `Navbar` component serves as the application's global navigation bar, providing quick access to various parts of the application such as the home page, settings, user profile, and a logout mechanism. It also integrates with the chat store to toggle the visibility of the friends list.

### Features

*   **Brand Link**: Directs users to the application's home page.
*   **Navigation Links**: Provides links to "Friends", "Settings", and "Profile" (if authenticated).
*   **Logout Functionality**: Allows authenticated users to log out.
*   **Friends List Toggle**: A button to show/hide the `Sidebar` (friends list) on smaller screens.
*   **Authentication-aware Rendering**: Displays "Profile" and "Logout" options only when a user is authenticated.

### Key Usage

The `Navbar` uses `useAuthStore` to determine the authentication status of the user (`authUser`) and provides the `logout` function. It also uses `useChatStore` for the `toggleFriendsBox` action.

```jsx
// frontend/src/components/Navbar.jsx
import { Link } from "react-router-dom";
import { useAuthStore } from "../store/useAuthStore";
import { LogOut, MessageSquare, Settings, User, Users } from "lucide-react";
import { useChatStore } from "../store/useChatStore";

const Navbar = () => {
  const { logout, authUser } = useAuthStore();
  const { toggleFriendsBox } = useChatStore(); 

  return (
    <header
      className=" bg-base-100 border-b border-base-300 fixed w-full top-0 z-40
        backdrop-blur-lg bg-base-100/80"
    >
      <div className="container mx-auto px-4 h-16">
        <div className="flex items-center justify-between h-full">
          <div className="flex items-center gap-8">
            <Link to="/" className="flex items-center gap-2.5 hover:opacity-80 transition-all">
              {/* Logo and App Name */}
            </Link>
          </div>
          <div className="flex items-center gap-4">
            <button className="btn btn-sm gap-2" onClick={toggleFriendsBox}>
              <Users className="size-5" />
              <span className="hidden sm:inline">Friends</span>
            </button>
            <Link to={"/settings"} className={`btn btn-sm gap-2 transition-colors`}>
              <Settings className="size-4"/>
              <span className="hidden sm:inline">Settings</span>
            </Link>
            {authUser && ( // Conditional rendering based on authentication
              <>
                <Link to={"/profile"} className={`btn btn-sm gap-2`}>
                  <User className="size-5" />
                  <span className="hidden sm:inline">Profile</span>
                </Link>
                <button className="btn btn-sm flex gap-2 items-center" onClick={logout}>
                  <LogOut className="size-5" />
                  <span className="hidden sm:inline">Logout</span>
                </button>
              </>
            )}
          </div>
        </div>
      </div>
    </header>
  );
};

export default Navbar;
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Navbar.jsx#L10-L64)

The conditional rendering (`{authUser && (...) }` on lines 43-57) ensures that profile and logout options are only visible to logged-in users, enhancing security and user experience. The `toggleFriendsBox` button provides a mechanism for responsiveness, allowing users on smaller screens to explicitly show/hide the sidebar.

## Sidebar Component

The `Sidebar` component displays a list of the user's friends, allowing them to select a friend to initiate or view a chat conversation. It also provides functionality to filter the list to show only online friends.

### Features

*   **Friends List Display**: Renders a list of all friends.
*   **Friend Selection**: Allows users to select a friend, updating the `selectedUser` in the chat store.
*   **Online/Offline Status**: Visually indicates if a friend is online or offline.
*   **Online Filter**: A checkbox to toggle between showing all friends and only online friends.
*   **Loading State**: Displays a skeleton loader while fetching the friends list.
*   **Responsiveness**: Adjusts its visibility based on `selectedUser` to optimize space on smaller screens.

### Key Usage

The `Sidebar` uses `useChatStore` to fetch friends (`getFriends`), manage the list of users (`users`), and set the `selectedUser`. It also integrates with `useAuthStore` to get the list of `onlineUsers`.

```jsx
// frontend/src/components/Sidebar.jsx
import { useEffect, useState } from "react";
import { useChatStore } from "../store/useChatStore";
import SidebarSkeleton from "./skeletons/SidebarSkeleton";
import { Users } from "lucide-react";
import { useAuthStore } from "../store/useAuthStore";

const Sidebar = () => {
    const { getFriends, users, selectedUser, setSelectedUser, isUsersLoading } =
        useChatStore();
    const { onlineUsers } = useAuthStore();
    const [showOnlineOnly, setShowOnlineOnly] = useState(false);

    useEffect(() => {
        getFriends(); // Fetch friends on component mount
    }, [getFriends]);

    const filteredUsers = showOnlineOnly
        ? users.filter((user) => onlineUsers.includes(user._id))
        : users;

    if (isUsersLoading) return <SidebarSkeleton />;

    return (
        <div className={`h-full sm:w-72 sm:border-r border-base-300  flex-col transition-all duration-200 ${selectedUser ?
                                    "hidden sm:flex w-[100vw] "
                                    : ""}`}>
            {/* ... JSX for header, online toggle, and friends list mapping */}
        </div>
    );
};

export default Sidebar;
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Sidebar.jsx#L7-L35)

The `useEffect` hook on lines 15-17 ensures that the `getFriends` action is called when the component mounts, populating the friends list. The `filteredUsers` computed property (lines 19-21) dynamically adjusts the displayed list based on the `showOnlineOnly` state and the `onlineUsers` array from `useAuthStore`. The CSS class logic on lines 31-33 (`${selectedUser ? "hidden sm:flex w-[100vw]" : ""}`) handles the responsive display, hiding the sidebar on small screens when a user is selected, giving priority to the chat view.

## Key Integration Points

These UI components, while modular, are deeply integrated to provide a cohesive chat experience.

1.  **State Management with Zustand**: `useChatStore` and `useAuthStore` are central to their operation. `ChatContainer` and `MessageInput` rely on `useChatStore` for messages and `selectedUser`, while `Navbar` and `Sidebar` use both `useAuthStore` (for `authUser`, `onlineUsers`) and `useChatStore` (for `selectedUser`, `toggleFriendsBox`).
2.  **Parent-Child Composition**: The main `ChatContainer` composes `ChatHeader` and `MessageInput`, creating a unified chat interface.
3.  **Real-time Interaction**: `ChatContainer`'s subscription to messages via `subscribeToMessages` ensures that new messages sent through `MessageInput` (which dispatches `sendMessage` to the store) are immediately reflected without manual refresh.
4.  **Responsive Design**: The `Sidebar` and `Navbar` collaborate to provide an adaptive layout. `Navbar`'s `toggleFriendsBox` offers a way to show/hide the `Sidebar` on smaller screens, which itself conditionally hides when a `selectedUser` is present, optimizing screen real estate for the chat view.
5.  **User Experience Consistency**: By reusing components and managing shared state, the application maintains a consistent look, feel, and functionality across different interactions (e.g., friend selection, message sending, status updates).