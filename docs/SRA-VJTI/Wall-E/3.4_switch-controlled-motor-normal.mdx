---
title: "Switch Controlled Motor Normal"
description: "Details of the switch controlled motor module."
sidebar_position: 34
---
 
---
title: "Switch Controlled Motor Normal"
description: "Details of the switch controlled motor module."
---

# Switch Controlled Motor Normal

## About the Project

This module focuses on controlling motors using switch inputs in "Normal Mode". The SRA board is equipped with two TB6612FNG motor drivers, enabling the control of up to four motors. This module specifically utilizes the normal mode of operation.

### Motor Driver Modes

The TB6612FNG motor driver offers two operational modes: Normal Mode and Parallel Mode. This section details the Normal Mode implementation.

1.  **Normal Mode**

    



```mermaid
    graph TD
        A["Motor Driver (TB6612FNG)"] --> B{{"IN1: HIGH, IN2: LOW"}};
        A --> C{{"IN1: LOW, IN2: HIGH"}};
        A --> D{{"IN1: LOW, IN2: LOW"}};
        A --> E{{"IN1: HIGH, IN2: HIGH"}};
        B --> F["Motor 1: Forward"];
        C --> G["Motor 1: Backward"];
        D --> H["Motor 1: Stop"];
        E --> H;
    ```



    The new design employs two motor drivers, allowing for the control of four motors using eight GPIO pins of the ESP32.

    For example, if GPIO pin 32 is HIGH (IN1 = HIGH) and pin 33 is LOW (IN2 = LOW), motor 1 will move forward.

    Motor 1 Control Table:

    | 32\\33 | High             | Low              |
    | :---- | :--------------- | :--------------- |
    | High  | Move motor forward | Move Motor Forward |
    | Low   | Move motor Backward| Stop Motor       |

    In Normal Mode, the motor driver provides a per-channel current capacity of 1.2A, allowing for the connection of four motors to the board.

## Working

The module operates as follows:

1.  Activates GPIO switches to receive input from the Line Sensor Array (LSA).
2.  Enables one of the two TB6612FNG motor drivers.
3.  Receives input from the LSA.
4.  Controls the bot motors in Normal Mode based on the input.

```c
// SRA's custom header file including additional functions
#include "sra_board.h"
```
[View on GitHub](https://github.com/SRA-VJTI/Wall-E/blob/main/4_switch_controlled_motor_normal/main/switch_control_motor_normal.c#L1-L3)
This snippet includes the necessary header file, "sra\_board.h", which contains custom functions for the SRA board.

```c
	ESP_ERROR_CHECK(enable_motor_driver(&motor_a_0, MOTOR_A_0));
	ESP_ERROR_CHECK(enable_motor_driver(&motor_a_1, MOTOR_A_1));
```
[View on GitHub](https://github.com/SRA-VJTI/Wall-E/blob/main/4_switch_controlled_motor_normal/main/switch_control_motor_normal.c#L30-L31)
This code snippet enables the motor drivers for motors A\_0 and A\_1 using the `enable_motor_driver` function. The `MOTOR_A_0` and `MOTOR_A_1` constants specify which motor driver to enable. The ESP\_ERROR\_CHECK macro is used for error handling.

```c
		if (read_switch(SWITCH_1))
		{
			set_motor_speed(motor_a_0, MOTOR_FORWARD, 80);
			ESP_LOGI(TAG_SWITCH_CONTROL_MOTOR, "MOTOR_A_0 FORWARD");
		}
```
[View on GitHub](https://github.com/SRA-VJTI/Wall-E/blob/main/4_switch_controlled_motor_normal/main/switch_control_motor_normal.c#L46-L51)
This section reads the state of `SWITCH_1`. If the switch is activated (returns true), it sets `motor_a_0` to move forward with a duty cycle of 80 using `set_motor_speed`. It also logs a message to indicate the motor's direction.

```c
			vTaskDelay(100 / portTICK_PERIOD_MS);
```
[View on GitHub](https://github.com/SRA-VJTI/Wall-E/blob/main/4_switch_controlled_motor_normal/main/switch_control_motor_normal.c#L91)
This line introduces a delay of 100 milliseconds using `vTaskDelay`. The `portTICK_PERIOD_MS` constant provides the tick period in milliseconds, ensuring that the task is delayed for the specified duration.

```c
	xTaskCreate(&drive_task, "drive_task", 4096, NULL, 1, NULL);
```
[View on GitHub](https://github.com/SRA-VJTI/Wall-E/blob/main/4_switch_controlled_motor_normal/main/switch_control_motor_normal.c#L102)
This code creates a FreeRTOS task named "drive\_task" with a stack size of 4096 words, a priority of 1, and no task handle or parameters. This task will execute the motor control logic.

## Key Integration Points

*   **LSA Input:** The module directly integrates with the LSA via the `read_switch()` function. This function determines the motor's direction and speed.
*   **Motor Driver Control:** The `set_motor_speed()` function is the core of the motor control, taking motor, direction, and speed as inputs.
*   **Error Handling:** The `ESP_ERROR_CHECK` macro ensures proper error handling during motor driver initialization.
*   **Task Management:** The `xTaskCreate()` function starts a FreeRTOS task, enabling concurrent operation with other system functions.
*   **Timing:** The use of `vTaskDelay()` introduces crucial timing considerations for smooth motor operation, preventing the control loop from consuming excessive resources.