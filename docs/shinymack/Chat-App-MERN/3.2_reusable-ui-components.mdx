---
title: "Reusable UI Components"
description: "Details the modular UI components used across the frontend for a consistent user experience."
sidebar_position: 32
---
 # Reusable UI Components

The frontend of the application leverages a modular approach to UI development, utilizing a suite of reusable React components. This strategy ensures consistency in design, improves maintainability, and accelerates development by breaking down complex interfaces into manageable, independent pieces. These components interact seamlessly with global state management (primarily `useChatStore` and `useAuthStore`) to provide a dynamic and responsive user experience.

This section details some of the core UI components, illustrating their purpose, functionality, and integration within the application.

## ChatContainer

The `ChatContainer` component is responsible for displaying the message history for the currently selected user. It orchestrates the fetching and rendering of messages, manages real-time updates, and integrates other smaller components like `ChatHeader` and `MessageInput`.

### Key Features

*   **Message Display**: Renders individual chat messages, distinguishing between sent and received messages.
*   **Real-time Updates**: Subscribes to new messages to ensure the chat view is always up-to-date.
*   **Auto-Scroll**: Automatically scrolls to the latest message, enhancing user experience in active chats.
*   **Loading State**: Provides a skeleton loader while messages are being fetched.
*   **Media Support**: Displays image attachments within message bubbles.

### Implementation Details

The component utilizes `useEffect` hooks to manage data fetching and real-time subscriptions based on the `selectedUser`. It also employs `useRef` to facilitate automatic scrolling to the end of the message list.

```jsx title="frontend/src/components/ChatContainer.jsx" {12-17}
// Link: [View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/ChatContainer.jsx#L12-L17)
    useEffect(() => {
        getMessages(selectedUser._id);
        subscribeToMessages();

        return () => unsubscribeFromMessages();
    }, [selectedUser._id, getMessages, subscribeToMessages, unsubscribeFromMessages]);
```
This `useEffect` hook is critical for managing the lifecycle of message data. When `selectedUser._id` changes, it triggers a fetch for messages related to that user and establishes a real-time subscription. The cleanup function (`unsubscribeFromMessages`) ensures that subscriptions are properly terminated when the component unmounts or the selected user changes, preventing memory leaks and stale data.

The component dynamically renders messages, applying different styles for messages sent by the authenticated user versus those received from the selected user. It also supports displaying images within message bubbles.

```jsx title="frontend/src/components/ChatContainer.jsx" {34-58}
// Link: [View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/ChatContainer.jsx#L34-L58)
                {messages.map((message) => (
                    <div
                        key={message._id}
                        className={`chat ${message.senderId == authUser._id ? "chat-end": "chat-start"} `}
                        ref={messageEndRef}
                    >
                        <div className="chat-image avatar">
                            <div className="size-9 rounded-full border">
                                <img
                                    src={message.senderId == authUser._id ? authUser.profilePic || "/avatar.png": selectedUser.profilePic || "/avatar.png"}
                                    alt="profilepic"
                                 />
                            </div>
                        </div>
                        <div className="chat-header mb-1">
                            <time className="text-xs opacity-50 ml-1">{formatMessageTime(message.createdAt)}</time>
                        </div>
                        <div className="chat-bubble flex flex-col">
                            {message.image && (
                                <img 
                                    src={message.image}
                                    alt="Attachment"
                                    className="sm:max-w-[200px] rounded-md " 
                                />
                            )}
                            {message.text && <p>{message.text}</p>}
                        </div>
                    </div>
                ))}
```
This snippet showcases the mapping of `messages` to individual `div` elements, with conditional CSS classes (`chat-end` or `chat-start`) applied based on whether the `senderId` matches the `authUser._id`. It also conditionally renders `img` tags for message attachments and `p` tags for text content, and formats the message timestamp.

## MessageInput

The `MessageInput` component provides the interface for users to compose and send messages. It supports both text and image attachments, offering a preview functionality for images before sending.

### Key Features

*   **Text Input**: A standard input field for typing messages.
*   **Image Attachment**: Allows users to select image files, displays a preview, and handles removal of the selected image.
*   **Send Functionality**: Dispatches the message (text and/or image) via the `sendMessage` action from `useChatStore`.
*   **Input Validation**: Ensures that at least text or an image is present before sending.

### Implementation Details

This component manages its own local state for the message text (`text`) and the image preview (`imagePreview`). It integrates `useRef` to control the hidden file input element and uses `FileReader` for image preview generation.

```jsx title="frontend/src/components/MessageInput.jsx" {30-43}
// Link: [View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/MessageInput.jsx#L30-L43)
    const handleSendMessage = async (e) => {
        e.preventDefault();
        if (!text.trim() && !imagePreview) return;

        try {
            await sendMessage({
                text: text.trim(),
                image: imagePreview,
            });

            setText("");
            setImagePreview(null);
            if (fileInputRef.current) fileInputRef.current = "";
        } catch (error) {
            console.error("Failed to send message", error);
        }
    };
```
The `handleSendMessage` function prevents default form submission, checks if there's any content to send, and then calls `sendMessage` from the chat store. Upon successful sending, it clears the input fields and image preview.

```jsx title="frontend/src/components/MessageInput.jsx" {48-67}
// Link: [View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/MessageInput.jsx#L48-L67)
            {imagePreview && (
                <div className="mb-3 flex items-center gap-2">
                    <div className="relative">
                        <img
                            src={imagePreview}
                            alt="Preview"
                            className="w-20 h-20 object-cover rounded-lg border border-zinc-700"
                        />
                        <button
                            onClick={removeImage}
                            className="absolute -top-1.5 -right-1.5 w-5 h-5 rounded-full bg-base-300
              flex items-center justify-center"
                            type="button"
                        >
                            <X className="size-3" />
                        </button>
                    </div>
                </div>
            )}
```
This section conditionally renders an image preview if `imagePreview` state is set. It includes a small 'X' button to remove the image, allowing users to change their mind before sending.

## Sidebar

The `Sidebar` component displays a list of the user's friends, allowing selection to initiate a chat. It also provides filtering options to view only online friends.

### Key Features

*   **Friend List Display**: Shows a list of friends with their profile pictures and usernames.
*   **Online Status Indicator**: Visually distinguishes online friends from offline ones.
*   **Friend Selection**: Clicking on a friend updates the `selectedUser` in the global state, triggering the `ChatContainer` to display their messages.
*   **Online Filter**: A checkbox to toggle between showing all friends and only online friends.
*   **Loading State**: Displays a skeleton loader while the friend list is being fetched.

### Implementation Details

The `Sidebar` fetches the list of friends using `getFriends` from `useChatStore` and checks their online status against `onlineUsers` from `useAuthStore`.

```jsx title="frontend/src/components/Sidebar.jsx" {10-12}
// Link: [View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Sidebar.jsx#L10-L12)
    useEffect(() => {
        getFriends();
    }, [getFriends]);
```
This `useEffect` ensures that the list of friends is loaded when the `Sidebar` component mounts. The `getFriends` function is a dependency to adhere to React's `useEffect` rules.

The `Sidebar` dynamically renders each friend, providing visual cues for their online status and applying an active style when a friend is selected.

```jsx title="frontend/src/components/Sidebar.jsx" {39-57}
// Link: [View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Sidebar.jsx#L39-L57)
                    {filteredUsers.map((user) => (
                        <button
                            key={user._id}
                            onClick={() => setSelectedUser(user)}
                            className={`sm:w-full w-[88vw] p-3 flex items-center gap-3 hover:bg-base-300 transition-colors
                            ${
                                selectedUser?._id === user._id
                                    ? "bg-base-300 ring-1 ring-base-300"
                                    : ""
                            }`}
                        >
                            <div className="relative mx-0">
                                <img
                                    src={user.profilePic || "/avatar.png"}
                                    alt={user.username}
                                    className="size-12 object-cover rounded-full"
                                />
                                {onlineUsers.includes(user._id) && (
                                    <span className="absolute bottom-0 right-0 size-3 bg-green-500 rounded-full ring-2 ring-zinc-900" />
                                )}
                            </div>
                            <div className=" block text-left min-w-0">
                                <div className=" font-medium truncate">
                                    {user.username}
                                </div>
                                <div className="text-sm text-zinc-400">
                                    {onlineUsers.includes(user._id)
                                        ? "Online"
                                        : "Offline"}
                                </div>
                            </div>
                        </button>
                    ))}
```
This iteration renders each friend as a clickable button. It conditionally displays a green dot for online users and updates the `selectedUser` state on click, which in turn affects the `ChatContainer`.

## FriendsBox

The `FriendsBox` component provides a modal interface for managing friend relationships, including adding new friends, reviewing pending requests, viewing sent requests, and removing existing friends.

### Key Features

*   **Friend Management Tabs**: Organizes friend-related actions into "Friends", "Pending", and "Sent" tabs.
*   **Add Friend**: An input field and button to send friend requests by username or email.
*   **Request Actions**: Allows accepting or rejecting pending friend requests.
*   **Friend Removal**: Provides an option to remove existing friends.
*   **Modal Overlay**: Presented as a full-screen overlay for focused interaction.

### Implementation Details

The component maintains `activeTab` and `identifier` states locally. It fetches various friend-related data (`getFriends`, `getPendingRequests`, `getSentRequests`) from `useChatStore` upon mounting.

```jsx title="frontend/src/components/FriendsBox.jsx" {17-21}
// Link: [View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/FriendsBox.jsx#L17-L21)
    useEffect(() => {
        getFriends();
        getPendingRequests();
        getSentRequests();
    }, [getFriends, getPendingRequests, getSentRequests]);
```
Similar to other components, this `useEffect` ensures that all necessary friend-related data is fetched when the `FriendsBox` is first rendered.

The `renderContent` function is a switch statement that dynamically renders the content based on the `activeTab` state, displaying lists of friends, pending requests, or sent requests.

```jsx title="frontend/src/components/FriendsBox.jsx" {26-77}
// Link: [View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/FriendsBox.jsx#L26-L77)
    const renderContent = () => {
        switch (activeTab) {
            case 'pending':
                return (
                    <div className="space-y-2">
                        {pendingRequests.length > 0 ? pendingRequests.map(req => (
                            <div key={req._id} className="flex items-center justify-between p-2 rounded-lg bg-base-200">
                                <div className="flex items-center gap-3">
                                    <img src={req.profilePic || '/avatar.png'} alt={req.username} className="size-10 rounded-full" />
                                    <span>{req.username}</span>
                                </div>
                                <div className="flex gap-2">
                                    <button onClick={() => acceptFriendRequest(req._id)} className="btn btn-xs btn-success btn-circle"><Check size={16}/></button>
                                    <button onClick={() => rejectFriendRequest(req._id)} className="btn btn-xs btn-error btn-circle"><X size={16}/></button>
                                </div>
                            </div>
                        )) : <p className="text-center text-base-content/60 py-4">No pending requests.</p>}
                    </div>
                );
            case 'sent':
                return (
                    <div className="space-y-2">
                        {sentRequests.length > 0 ? sentRequests.map(req => (
                             <div key={req._id} className="flex items-center justify-between p-2 rounded-lg bg-base-200">
                                <div className="flex items-center gap-3">
                                    <img src={req.profilePic || '/avatar.png'} alt={req.username} className="size-10 rounded-full" />
                                    <span>{req.username}</span>
                                </div>
                                <span className="text-sm text-base-content/50">Pending</span>
                            </div>
                        )) : <p className="text-center text-base-content/60 py-4">No sent requests.</p>}
                    </div>
                );
            case 'friends':
            default:
                return (
                    <div className="space-y-2">
                        {users.length > 0 ? users.map(friend => (
                            <div key={friend._id} className="flex items-center justify-between p-2 rounded-lg bg-base-200">
                               <div className="flex items-center gap-3">
                                    <img src={friend.profilePic || '/avatar.png'} alt={friend.username} className="size-10 rounded-full" />
                                    <span>{friend.username}</span>
                                </div>
                                <button onClick={() => removeFriend(friend._id)} className="btn btn-xs btn-ghost btn-circle text-error"><Trash2 size={16}/></button>
                            </div>
                        )) : <p className="text-center text-base-content/60 py-4">You have no friends yet.</p>}
                    </div>
                );
        }
    };
```
This function demonstrates conditional rendering based on the `activeTab`. Each case maps its respective data (`pendingRequests`, `sentRequests`, `users`) to display friend information and interactive buttons for managing those relationships.

## Component Interaction Diagram

This diagram illustrates how the primary chat-related UI components interact with each other and with the shared Zustand stores.





```mermaid
graph TD
    A["Sidebar"] --> B["ChatContainer"]: "Selects User"
    B --> C["MessageInput"]: "Contains Input Area"
    B --> D["ChatHeader"]: "Displays Chat Info"
    A -- "Updates 'selectedUser'" --> E["useChatStore"]: "Manages Chat State"
    C -- "Sends Message" --> E
    B -- "Retrieves Messages" --> E
    A -- "Retrieves 'users', 'onlineUsers'" --> E
    F["useAuthStore"] -- "Provides 'authUser', 'onlineUsers'" --> A
    F --> B
```



## Friends Management Flow

This diagram outlines the user flow and data interactions within the `FriendsBox` component.





```mermaid
flowchart LR
    A["FriendsBox Component"] -- "User clicks tab" --> B["Update activeTab State"]
    B -- "Renders corresponding content" --> C["Display Friends List"]
    B --> D["Display Pending Requests"]
    B --> E["Display Sent Requests"]

    A -- "User inputs identifier & clicks 'Add Friend'" --> F["sendFriendRequest(identifier)"]
    D -- "User clicks 'Accept'" --> G["acceptFriendRequest(id)"]
    D -- "User clicks 'Reject'" --> H["rejectFriendRequest(id)"]
    C -- "User clicks 'Remove'" --> I["removeFriend(id)"]

    F --> J["useChatStore"]: "Updates server via API"
    G --> J
    H --> J
    I --> J
    J -- "Updates local state" --> A
```



## Key Integration Points

The reusable UI components work in concert to form the complete chat application interface. Their primary integration points revolve around:

*   **Zustand State Management (`useChatStore`, `useAuthStore`)**: This is the central nervous system. Components like `Sidebar`, `ChatContainer`, and `FriendsBox` subscribe to state changes (e.g., `selectedUser`, `messages`, `users`, `onlineUsers`) and dispatch actions (e.g., `getMessages`, `sendMessage`, `sendFriendRequest`) to update the global state. This ensures data consistency and efficient re-rendering.
*   **Component Composition**: Larger components like `ChatContainer` compose smaller, focused components (`ChatHeader`, `MessageInput`). This promotes reusability and separation of concerns.
*   **Real-time Communication**: The `useChatStore`'s `subscribeToMessages` and `unsubscribeFromMessages` actions, utilized by `ChatContainer`, are crucial for providing a real-time chat experience, updating messages as they arrive without manual refresh.
*   **User Experience Enhancements**: Features like auto-scrolling in `ChatContainer` and image previews in `MessageInput` are small, focused enhancements built directly into the reusable components, contributing to a polished user interface.
*   **Conditional Rendering and Styling**: Components dynamically adjust their appearance and displayed content based on state (e.g., `selectedUser`, `onlineUsers`, `activeTab`), providing a responsive and intuitive interface.