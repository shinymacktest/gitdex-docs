---
title: "Self Balancing: Backend"
description: "Details of the backend implementation of the self balancing module."
sidebar_position: 51
---
 # Self Balancing: Backend

This section delves into the backend implementation of the self-balancing module, covering key files, functionalities, and integration points. The backend is primarily responsible for handling the WiFi connection, managing PID tuning parameters via a WebSocket server, and plotting data for analysis.

## Core Components and Functionality

The backend implementation comprises several key components working together to achieve the self-balancing functionality.

### 1. `idf_component.yml`

This file, [View on GitHub](https://github.com/SRA-VJTI/Wall-E/blob/main/7_self_balancing/main/idf_component.yml), is the component manifest file used by the ESP-IDF component manager. It specifies the dependencies required for the project. In this case, it includes a dependency on the `espressif/mdns` component for mDNS support. This allows the ESP32 to be discoverable on the network.

```yml
dependencies:
  espressif/mdns: "^1.0.7"
  ## Required IDF version
  idf:
    version: ">=4.1.0"
```

### 2. `tuning_websocket_server.h`

This header file, [View on GitHub](https://github.com/SRA-VJTI/Wall-E/blob/main/7_self_balancing/main/include/tuning_websocket_server.h), defines the structures, functions, and constants used for the WebSocket server and PID tuning.  It includes necessary headers for FreeRTOS, GPIO, SPIFFS, networking, HTTP server, cJSON, and custom headers like `wifi_handler.h` and `websocket_server.h`. Key structures like `pid_const_t` and `plot_graph_data_t` are defined here, along with function prototypes for managing PID constants, starting the server, and plotting graph data.

```c
typedef struct pid_const
{
    float kp;
    float ki;
    float kd;
    float setpoint;
    float offset;
    bool val_changed;
} pid_const_t;
```

### 3. `wifi_handler.h`

This header file, [View on GitHub](https://github.com/SRA-VJTI/Wall-E/blob/main/7_self_balancing/main/include/wifi_handler.h), provides the definitions and prototypes for the WiFi connection handling. It defines constants related to WiFi configuration, such as SSID, password, and retry limits. It also declares the function `connect_to_wifi()` which is responsible for establishing the WiFi connection.

```c
#define WIFI_SSID      CONFIG_WIFI_SSID
#define WIFI_PASS      CONFIG_WIFI_PASSWORD
#define MAXIMUM_RETRY  CONFIG_MAXIMUM_RETRY

void connect_to_wifi();
```

### 4. `tuning_websocket_server.c`

This source file, [View on GitHub](https://github.com/SRA-VJTI/Wall-E/blob/main/7_self_balancing/main/tuning_websocket_server.c), implements the WebSocket server functionality for PID tuning and data plotting. The server uses mDNS for service discovery, allowing clients to connect to the ESP32.  It handles incoming WebSocket messages, parsing them to update PID constants (Kp, Ki, Kd, Setpoint, Offset).  It also includes functions for sending data for plotting graphs on the client side.

*   **mDNS Initialization:** The `initialise_mdns()` function initializes the mDNS service, setting the hostname and instance name. It adds a service for an HTTP server, allowing for easy access to a web interface for tuning.

    ```c
    static void initialise_mdns(void)
    {
        mdns_init();
        mdns_hostname_set(MDNS_HOST_NAME);
        mdns_instance_name_set(MDNS_INSTANCE);

        mdns_txt_item_t serviceTxtData[] = {
            {"board", "esp32"},
            {"path", "/"}};

        ESP_ERROR_CHECK(mdns_service_add("ESP32-WebServer", "_http", "_tcp", 80, serviceTxtData,
                                         sizeof(serviceTxtData) / sizeof(serviceTxtData[0])));
    }
    ```

*   **WebSocket Callback:** The `websocket_callback()` function handles incoming WebSocket messages. It parses messages, updates PID constants, and logs relevant information.

    ```c
    void websocket_callback(uint8_t num, WEBSOCKET_TYPE_t type, char *msg, uint64_t len)
    {
        // ... (message handling logic) ...
    }
    ```

*   **Data Plotting:** The `plot_graph()` function is responsible for sending data to the client for plotting. The `plot_graph_task()` function reads data from a queue and calls `plot_graph()` to send data over the websocket.

*   **Server Tasks:** The code implements two FreeRTOS tasks: `server_task` which listens for incoming connections and `server_handle_task` which handles the HTTP and WebSocket connections.

### 5. `wifi_handler.c`

This source file, [View on GitHub](https://github.com/SRA-VJTI/Wall-E/blob/main/7_self_balancing/main/wifi_handler.c), manages the WiFi connection.  It initializes the ESP32's WiFi in station mode, connects to the specified access point (defined by `WIFI_SSID` and `WIFI_PASS`), and handles connection events.

*   **Event Handling:**  The `event_handler()` function handles WiFi events, such as connection attempts, successful connections, and disconnections. It sets the appropriate bits in the `s_wifi_event_group` to signal the connection status.

    ```c
    static void event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data)
    {
        // ... (event handling logic) ...
    }
    ```

*   **WiFi Initialization:** The `wifi_init_sta()` function initializes the WiFi stack, sets the WiFi mode to station mode, configures the WiFi settings, and starts the WiFi.

    ```c
    void wifi_init_sta(void)
    {
        // ... (WiFi initialization) ...
    }
    ```

## Key Integration Points

The backend integrates several components to provide the self-balancing functionality.

1.  **WiFi Connection and Network Setup:** The `wifi_handler.c` file is crucial for connecting to a WiFi network. Once connected, the ESP32 obtains an IP address, enabling communication over the network.

    



```mermaid
    graph TD
        A["ESP32 (WiFi Handler)"] --> B{Connect to WiFi};
        B -- "Success" --> C["Obtain IP Address"];
        B -- "Failure" --> D["Retry Connection"];
        C --> E["Start mDNS Service"];
        E --> F["Start WebSocket Server"];
    ```



2.  **WebSocket Server for PID Tuning:** The `tuning_websocket_server.c` file provides a WebSocket server that allows users to connect and modify PID constants in real-time. Clients can send messages to change parameters. These changes are then applied to the self-balancing algorithm.

    



```mermaid
graph TD
A["Component"] --> B["Service"]
C --> B
```



3.  **Data Plotting and Visualization:** The `tuning_websocket_server.c` file also supports plotting data. The `plot_graph()` function formats and sends data to the connected client. This data can then be visualized using a charting library on the client-side, providing insights into the system's performance.

4.  **mDNS for Service Discovery:** The use of mDNS (Multicast DNS) allows clients on the same network to easily discover the ESP32. By advertising the WebSocket server, clients can connect without needing to know the ESP32's IP address.

## Best Practices and Insights

*   **Modularity:** The code is well-structured with clear separation of concerns, making it easier to maintain and extend. Each file has a specific role, contributing to overall code readability.
*   **Configuration:** The use of `CONFIG_WIFI_SSID` and `CONFIG_WIFI_PASSWORD` suggests that the WiFi credentials are configured through the ESP-IDF menuconfig. This is a standard and secure practice.
*   **Error Handling:** The code includes error checks for critical functions, such as initializing WiFi and handling network connections, improving robustness.
*   **Real-time Tuning:** The WebSocket server enables real-time tuning of PID parameters, allowing for efficient optimization of the self-balancing system.
*   **Data Visualization:** The ability to plot graph data aids in understanding the system's response to different PID settings, making the tuning process more effective.