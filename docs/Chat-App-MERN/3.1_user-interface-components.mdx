---
title: "User Interface Components"
description: "Descriptions of reusable UI components and their functionalities."
sidebar_position: 31
---

---
title: "User Interface Components"
description: "Descriptions of reusable UI components and their functionalities."
sidebar_position: 31
---

# User Interface Components

<TOC />

This section details the core reusable UI components within the `frontend/src/components` directory. These components are built with React and leverage Zustand for state management, providing a dynamic and responsive user experience for the chat application.

## ChatContainer

The `ChatContainer` component is responsible for displaying the messages within a selected chat, rendering individual messages, and handling real-time updates.

### Functionality Overview

- **Message Display**: Renders a list of messages for the currently `selectedUser`.
- **Real-time Updates**: Subscribes to new messages via WebSockets, ensuring the chat updates instantly.
- **Scroll Management**: Automatically scrolls to the latest message as new messages arrive.
- **Loading State**: Displays a skeleton loader while messages are being fetched.
- **User Context**: Distinguishes between messages sent by the authenticated user and those from the selected contact, applying appropriate styling.

### Key Features

- **Dynamic Content**: Uses `messages.map` to iterate and display messages, including text and image attachments.
- **User Avatars**: Displays sender's profile pictures.
- **Timestamping**: Shows when each message was sent.
- **Scroll-to-Bottom**: The `useEffect` hook combined with `useRef` ensures the view automatically scrolls to the newest message.

```jsx title="frontend/src/components/ChatContainer.jsx" {21-25}
import { useEffect } from "react";
import { useChatStore } from "../store/useChatStore";
import ChatHeader from "./ChatHeader";
import MessageInput from "./MessageInput";
import MessageSkeleton from "./skeletons/MessageSkeleton";
import { useAuthStore } from "../store/useAuthStore";
import { formatMessageTime } from "../lib/utils";
import { useRef } from "react";

const ChatContainer = () => {
    const { messages, getMessages, isMessagesLoading, selectedUser, subscribeToMessages, unsubscribeFromMessages } =
        useChatStore();
    const { authUser } = useAuthStore();
    const messageEndRef = useRef(null);


    useEffect(() => {
        getMessages(selectedUser._id);
        subscribeToMessages();

        return () => unsubscribeFromMessages();
    }, [selectedUser._id, getMessages, subscribeToMessages, unsubscribeFromMessages]);
    
    useEffect(() => {
        if(messageEndRef.current && messages){
            messageEndRef.current.scrollIntoView({behaviour : "smooth"})
        }
    }, [messages])

    if (isMessagesLoading)
        return (
            <div className="flex-1 flex flex-col overflow-auto">
                <ChatHeader />
                <MessageSkeleton />
                <MessageInput />
            </div>
        );
    return (
        // ... (rest of the component)
    );
};

export default ChatContainer;
```
<p align="right">[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/ChatContainer.jsx)</p>

The `useEffect` hooks manage message fetching, real-time subscription, and automatic scrolling. The `messageEndRef` is crucial for maintaining a smooth chat experience by ensuring the latest message is always in view.

### Chat Message Rendering Logic

Messages are dynamically rendered, with different styles applied based on whether the `authUser` is the sender or receiver. Image attachments are also handled gracefully within the message bubble.

```jsx title="frontend/src/components/ChatContainer.jsx" {40-59}
// ... (previous code)
    return (
        <div className="flex-1 flex flex-col overflow-auto">
            <ChatHeader />
            <div className="flex-1 overflow-y-auto p-4 space-y-4">
                {messages.map((message) => (
                    <div
                        key={message._id}
                        className={`chat ${message.senderId == authUser._id ? "chat-end": "chat-start"} `}
                        ref={messageEndRef}
                    >
                        <div className="chat-image avatar">
                            <div className="size-9 rounded-full border">
                                <img
                                    src={message.senderId == authUser._id ? authUser.profilePic || "/avatar.png": selectedUser.profilePic || "/avatar.png"}
                                    alt="profilepic"
                                 />
                            </div>
                        </div>
                        <div className="chat-header mb-1">
                            <time className="text-xs opacity-50 ml-1">{formatMessageTime(message.createdAt)}</time>
                        </div>
                        <div className="chat-bubble flex flex-col">
                            {message.image && (
                                <img 
                                    src={message.image}
                                    alt="Attachment"
                                    className="sm:max-w-[200px] rounded-md " 
                                />
                            )}
                            {message.text && <p>{message.text}</p>}
                        </div>
                    </div>
                ))}
            </div>
            <MessageInput />
        </div>
    );
};

export default ChatContainer;
```
<p align="right">[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/ChatContainer.jsx#L40-L59)</p>

## FriendsBox

The `FriendsBox` component manages friend-related functionalities, including displaying friends, pending requests, sent requests, and sending/accepting/rejecting friend requests.

### Functionality Overview

- **Friend Management**: Fetches and displays current friends.
- **Request Management**: Shows pending and sent friend requests.
- **Actions**: Provides buttons to accept, reject, or remove friends.
- **Add Friend**: Allows users to send new friend requests by entering a username or email.
- **Tabbed Interface**: Organizes friend information into "Friends", "Pending", and "Sent" tabs.

### State Management and Actions

The component heavily relies on the `useChatStore` for all friend-related data and actions.

```jsx title="frontend/src/components/FriendsBox.jsx" {6-12}
import { useEffect, useState } from 'react';
import { useChatStore } from '../store/useChatStore';
import { X, UserPlus, Check, Trash2 } from 'lucide-react';

const FriendsBox = () => {
    const { 
        toggleFriendsBox, 
        getFriends, users,
        getPendingRequests, pendingRequests,
        getSentRequests, sentRequests,
        sendFriendRequest, acceptFriendRequest, rejectFriendRequest, removeFriend
    } = useChatStore();

    const [activeTab, setActiveTab] = useState('friends');
    const [identifier, setIdentifier] = useState('');

    useEffect(() => {
        // Fetch all necessary data when the component mounts
        getFriends();
        getPendingRequests();
        getSentRequests();
    }, [getFriends, getPendingRequests, getSentRequests]);

    // ... (rest of the component)
};

export default FriendsBox;
```
<p align="right">[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/FriendsBox.jsx)</p>

The `useEffect` hook ensures that all necessary friend data is loaded when the `FriendsBox` is rendered.

### Friend Management Flow

The following diagram illustrates the interaction flow for managing friends through the `FriendsBox` component:





```mermaid
graph TD
    A["FriendsBox (UI)"] --> B["useChatStore (Zustand)"]
    B -->|getFriends()| C["API: /api/users/friends"]
    B -->|getPendingRequests()| D["API: /api/users/requests/pending"]
    B -->|getSentRequests()| E["API: /api/users/requests/sent"]
    A -->|submit Add Friend| F["sendFriendRequest(identifier)"]
    F --> B
    B --> G["API: /api/users/add-friend"]
    A -->|click Accept Request| H["acceptFriendRequest(requestId)"]
    H --> B
    B --> I["API: /api/users/requests/accept"]
    A -->|click Reject Request| J["rejectFriendRequest(requestId)"]
    J --> B
    B --> K["API: /api/users/requests/reject"]
    A -->|click Remove Friend| L["removeFriend(friendId)"]
    L --> B
    B --> M["API: /api/users/remove-friend"]
```



## MessageInput

The `MessageInput` component provides the interface for users to compose and send messages, including text and image attachments.

### Functionality Overview

- **Text Input**: Allows users to type messages.
- **Image Attachment**: Supports attaching images with a preview feature.
- **Image Preview/Removal**: Displays a preview of the selected image and allows its removal before sending.
- **Message Sending**: Dispatches messages to the chat store.
- **Validation**: Ensures that either text or an image is present before sending.

### Core Logic for Message and Image Handling

The component uses local state (`text`, `imagePreview`) to manage the input fields and image selection. `useRef` is used to programmatically trigger the hidden file input.

```jsx title="frontend/src/components/MessageInput.jsx" {5-6, 11-20}
import { useRef, useState } from "react";
import { useChatStore } from "../store/useChatStore";
import { Image, Send, X } from "lucide-react";
import toast from "react-hot-toast";

const MessageInput = () => {
    const [text, setText] = useState("");
    const [imagePreview, setImagePreview] = useState(null);
    const fileInputRef = useRef(null);
    const { sendMessage } = useChatStore();

    const handleImageChange = (e) => {
        const file = e.target.files[0];
        if (!file.type.startsWith("image/")) {
            toast.error("Please select an image file");
            return;
        }

        const reader = new FileReader();
        reader.onloadend = () => {
            setImagePreview(reader.result);
        };
        reader.readAsDataURL(file);
    };

    const removeImage = () => {
        setImagePreview(null);
        if (fileInputRef.current) fileInputRef.current.value = "";
    };

    // ... (rest of the component)
};

export default MessageInput;
```
<p align="right">[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/MessageInput.jsx)</p>

The `handleImageChange` function reads the selected image file and sets it as a data URL for `imagePreview`, which is then displayed to the user.

### Sending Messages

The `handleSendMessage` function orchestrates sending the message payload to the backend via the `sendMessage` action from `useChatStore`.

```jsx title="frontend/src/components/MessageInput.jsx" {32-44}
// ... (previous code)

    const handleSendMessage = async (e) => {
        e.preventDefault();
        if (!text.trim() && !imagePreview) return;

        try {
            await sendMessage({
                text: text.trim(),
                image: imagePreview,
            });

            setText("");
            setImagePreview(null);
            if (fileInputRef.current) fileInputRef.current = "";
        } catch (error) {
            console.error("Failed to send message", error);
        }
    };

    return (
        // ... (rest of the component)
    );
};

export default MessageInput;
```
<p align="right">[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/MessageInput.jsx#L32-L44)</p>

This snippet demonstrates how the message and image data are packaged and sent. After successful submission, the input fields are cleared.

## Sidebar

The `Sidebar` component displays a list of the user's friends, indicating their online/offline status, and allows the user to select a friend to initiate or continue a chat.

### Functionality Overview

- **Friend Listing**: Displays a list of all friends.
- **Online Status**: Visually indicates which friends are currently online.
- **User Selection**: Allows clicking on a friend to set them as the `selectedUser`, updating the main chat area.
- **Filter**: Provides a checkbox to filter and display only online friends.
- **Loading State**: Shows a skeleton loader while friends data is being fetched.

### Friend List Management

The `Sidebar` fetches friends from `useChatStore` and monitors `onlineUsers` from `useAuthStore` to update their status.

```jsx title="frontend/src/components/Sidebar.jsx" {6-9, 13-17}
import { useEffect, useState } from "react";
import { useChatStore } from "../store/useChatStore";
import SidebarSkeleton from "./skeletons/SidebarSkeleton";
import { Users } from "lucide-react";
import { useAuthStore } from "../store/useAuthStore";

const Sidebar = () => {
    const { getFriends, users, selectedUser, setSelectedUser, isUsersLoading } =
        useChatStore();

    const { onlineUsers } = useAuthStore();
    const [showOnlineOnly, setShowOnlineOnly] = useState(false);
    useEffect(() => {
        getFriends();
    }, [getFriends]);
    const filteredUsers = showOnlineOnly
        ? users.filter((user) => onlineUsers.includes(user._id))
        : users;
    if (isUsersLoading) return <SidebarSkeleton />;
    return (
        // ... (rest of the component)
    );
};

export default Sidebar;
```
<p align="right">[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Sidebar.jsx)</p>

The `filteredUsers` array ensures that the displayed list respects the "Show online only" filter.

### User Selection and Online Status

Each friend in the sidebar is a clickable element that updates the `selectedUser` in the global chat state. Their online status is displayed using a green dot and text.

```jsx title="frontend/src/components/Sidebar.jsx" {50-68}
// ... (previous code)
                <div className="overflow-y-scroll h-[calc(100vh-14rem)] w-full flex flex-col py-3">
                    {filteredUsers.map((user) => (
                        <button
                            key={user._id}
                            onClick={() => setSelectedUser(user)}
                            className={`sm:w-full w-[88vw] p-3 flex items-center gap-3 hover:bg-base-300 transition-colors
                            ${
                                selectedUser?._id === user._id
                                    ? "bg-base-300 ring-1 ring-base-300"
                                    : ""
                            }`}
                        >
                            <div className="relative mx-0">
                                <img
                                    src={user.profilePic || "/avatar.png"}
                                    alt={user.username}
                                    className="size-12 object-cover rounded-full"
                                />
                                {onlineUsers.includes(user._id) && (
                                    <span className="absolute bottom-0 right-0 size-3 bg-green-500 rounded-full ring-2 ring-zinc-900" />
                                )}
                            </div>
                            <div className=" block text-left min-w-0">
                                <div className=" font-medium truncate">
                                    {user.username}
                                </div>
                                <div className="text-sm text-zinc-400">
                                    {onlineUsers.includes(user._id)
                                        ? "Online"
                                        : "Offline"}
                                </div>
                            </div>
                        </button>
                    ))}
                </div>
                {filteredUsers.length == 0 && (
                    <div className="text-center text-zinc-500 py-4">No online friends</div>
                )}
            </div>
        </div>
    );
};

export default Sidebar;
```
<p align="right">[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Sidebar.jsx#L50-L68)</p>

This section highlights the conditional rendering of the online status indicator and the styling applied to the currently selected user.

## Key Integration Points

These UI components are deeply integrated with the Zustand stores (`useChatStore`, `useAuthStore`) to manage application state and interact with the backend API.

- **Centralized State**: `useChatStore` acts as the single source of truth for chat messages, selected users, friend lists, and requests. `useAuthStore` manages authentication status and online users.
- **Real-time Communication**: The `ChatContainer` subscribes to message updates, demonstrating how UI reacts to WebSocket events managed by the stores.
- **Component-Store Interaction**: Each component dispatches actions (e.g., `sendMessage`, `getFriends`, `setSelectedUser`) to update the store, and listens to state changes from the store to re-render.
- **Modularity**: Breaking down the UI into these distinct components promotes reusability and easier maintenance. `MessageInput` is used within `ChatContainer`, and `FriendsBox` is a standalone overlay.

This architecture ensures a clear separation of concerns, with UI components focusing solely on presentation and user interaction, while state management is delegated to Zustand.

Next: [Page Structure and Routing](./3.2_page-structure-and-routing.mdx)
```