---
title: "Utility and External Services"
description: "Documents shared utilities, helper functions, and integrations with external services like Cloudinary."
sidebar_position: 23
---
 # Utility and External Services

This section details the common utilities, helper functions, and external service integrations that are crucial for various backend operations. These components ensure secure authentication, efficient file storage, and streamlined social interactions within the application.

## Core Utilities

The `backend/src/lib/utils.js` file houses general-purpose utility functions that support different parts of the backend. Currently, its primary function is generating JSON Web Tokens (JWT) for user authentication.

### JWT Generation

The `generateToken` function creates a signed JWT and sets it as an HTTP-only cookie. This ensures secure, stateless authentication for users by leveraging `jsonwebtoken`.

```javascript
// backend/src/lib/utils.js
import jwt from 'jsonwebtoken';

export const generateToken = (userId, res) => {
    const token = jwt.sign({userId}, process.env.JWT_SECRET, 
        {expiresIn: "7d"});

    res.cookie("jwt", token, {
        maxAge: 7 * 24 * 60 * 60 * 1000, 
        httpOnly: true,
        sameSite: "strict",
        secure: process.env.NODE_ENV !== "development",
    });
    return token;
};
```
**Explanation:**
*   The `jwt.sign` method creates a new token, embedding the `userId` as its payload, signed with `process.env.JWT_SECRET`.
*   The token is set as a `jwt` cookie with a 7-day expiry.
*   `httpOnly: true` prevents client-side JavaScript access to the cookie, mitigating XSS attacks.
*   `sameSite: "strict"` prevents the cookie from being sent with cross-site requests, enhancing CSRF protection.
*   `secure: true` (in production) ensures the cookie is only sent over HTTPS.

[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/lib/utils.js#L4-L14)

## External Service Integrations

### Cloudinary for Media Storage

The application integrates with Cloudinary for robust cloud-based image and video storage, management, and delivery. This offloads media handling from the server, improving performance and scalability.

```javascript
// backend/src/lib/cloudinary.js
import {v2 as cloudinary} from "cloudinary"
import { config } from 'dotenv'

config();

cloudinary.config(
    {cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
    api_key: process.env.CLOUDINARY_API_KEY,
    api_secret: process.env.CLOUDINARY_API_SECRET,}
);

export default cloudinary;
```
**Explanation:**
*   This file initializes the Cloudinary SDK using API credentials loaded from environment variables.
*   The `cloudinary` object is then exported, making it available for file upload and management operations throughout the backend, particularly for user profile pictures or shared media.

[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/lib/cloudinary.js#L1-L12)

### Passport.js for Google OAuth Authentication

`passport.config.js` sets up Passport.js with a Google OAuth 2.0 strategy, enabling users to authenticate using their Google accounts. This simplifies the registration and login process.

```javascript
// backend/src/lib/passport.config.js
import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import User from '../models/user.model.js'; 
import dotenv from 'dotenv';

dotenv.config(); 

export const configurePassport = () => {
    passport.use(new GoogleStrategy({
        clientID: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET,
        callbackURL: process.env.GOOGLE_CALLBACK_URL,
        scope: ['profile', 'email'] 
    },
    async (accessToken, refreshToken, profile, done) => {
        try {
            let user = await User.findOne({ googleId: profile.id });

            if (user) {
                return done(null, user);
            } else {
                // Logic for creating new user or handling existing email
            }
        } catch (error) {
            return done(error, null);
        }
    }));

    passport.serializeUser((user, done) => {
        done(null, user.id); 
    });

    passport.deserializeUser(async (id, done) => {
        try {
            const user = await User.findById(id);
            done(null, user); 
        } catch (error) {
            done(error, null);
        }
    });
};
```
**Explanation:**
*   **GoogleStrategy:** Configured with client ID, secret, callback URL, and requested scopes (`profile`, `email`).
*   **Verify Callback:** This asynchronous function handles the response from Google. It checks if a user with the Google ID already exists. If not, it attempts to create a new user, generating a unique username and validating the email.
*   **Serialization/Deserialization:** These functions manage how user data is stored in the session (`serializeUser` saves the user's `_id`) and retrieved from it (`deserializeUser` fetches the full user object from the database using the stored ID).

[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/lib/passport.config.js#L1-L69)

## Friend Management Controller

The `backend/src/controllers/friend.controller.js` file contains the logic for managing friend relationships between users, including sending, accepting, rejecting requests, and removing friends.

### Sending Friend Requests

The `sendFriendRequest` function handles the initiation of a friend request.

```javascript
// backend/src/controllers/friend.controller.js
export const sendFriendRequest = async (req, res) => {
    try {
        const { identifier } = req.body; 
        const senderId = req.user._id;

        if (!identifier) {
            return res.status(400).json({ message: "Username or email is required." });
        }

        const receiver = await User.findOne({
            $or: [{ username: identifier }, { email: identifier }]
        });

        if (!receiver) {
            return res.status(404).json({ message: "User not found." });
        }
        
        const receiverId = receiver._id;

        if (senderId.toString() === receiverId.toString()) {
            return res.status(400).json({ message: "You cannot send a friend request to yourself." });
        }

        const sender = await User.findById(senderId);

        if (sender.friends.includes(receiverId)) {
            return res.status(400).json({ message: "You are already friends with this user." });
        }
        // ... other checks for existing requests ...

        sender.sentRequests.push(receiverId);
        receiver.friendRequests.push(senderId);

        await sender.save();
        await receiver.save();

        res.status(200).json({ message: "Friend request sent successfully." });

    } catch (error) {
        console.error("Error in sendFriendRequest: ", error.message);
        res.status(500).json({ message: "Internal server error", error: error.message });
    }
};
```
**Explanation:**
*   Finds the receiver by username or email.
*   Performs various validation checks (not sending to self, already friends, request already sent/received).
*   Updates the `sentRequests` array for the sender and `friendRequests` array for the receiver.

[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/friend.controller.js#L10-L53)

### Accepting Friend Requests

The `acceptFriendRequest` function processes incoming friend requests.

```javascript
// backend/src/controllers/friend.controller.js
export const acceptFriendRequest = async (req, res) => {
    try {
        const { senderId } = req.params; 
        const receiverId = req.user._id; 

        const sender = await User.findById(senderId);
        const receiver = await User.findById(receiverId);

        if (!sender || !receiver) {
            return res.status(404).json({ message: "User not found." });
        }

        if (!receiver.friendRequests.includes(senderId)) {
            return res.status(400).json({ message: "Friend request not found or already handled." });
        }

        receiver.friends.push(senderId);
        sender.friends.push(receiverId);

        receiver.friendRequests = receiver.friendRequests.filter(id => id.toString() !== senderId.toString());
        sender.sentRequests = sender.sentRequests.filter(id => id.toString() !== receiverId.toString());

        await receiver.save();
        await sender.save();

        res.status(200).json({ message: "Friend request accepted." });

    } catch (error) {
        console.error("Error in acceptFriendRequest: ", error.message);
        res.status(500).json({ message: "Internal server error", error: error.message });
    }
};
```
**Explanation:**
*   Verifies the existence of sender and receiver.
*   Confirms the request is pending in the receiver's `friendRequests`.
*   Adds both users to each other's `friends` lists.
*   Removes the request from `friendRequests` (receiver) and `sentRequests` (sender).

[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/friend.controller.js#L56-L96)

### Retrieving Friend Lists and Requests

Functions like `getFriends`, `getPendingRequests`, and `getSentRequests` allow users to view their current friends and the status of their friend requests.

```javascript
// backend/src/controllers/friend.controller.js
export const getFriends = async (req, res) => {
    try {
        const userId = req.user._id;
        const user = await User.findById(userId).populate({
            path: "friends",
            select: "username email profilePic _id" 
        });

        if (!user) {
            return res.status(404).json({ message: "User not found." });
        }

        res.status(200).json(user.friends);

    } catch (error) {
        console.error("Error in getFriends: ", error.message);
        res.status(500).json({ message: "Internal server error", error: error.message });
    }
};
```
**Explanation:**
*   These functions query the current user's document and `populate` the relevant arrays (`friends`, `friendRequests`, `sentRequests`) with actual `User` objects, selecting specific fields for privacy and efficiency.

[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/friend.controller.js#L145-L162)

## Key Integration Points

### Authentication Flow (Local + Google OAuth)

The application provides both traditional username/password authentication (local) and Google OAuth, offering flexibility to users. JWTs are central to managing session state for local logins, while Passport.js handles the OAuth handshake and user session management.





```mermaid
graph TD
    A["User"] -->| "Registers/Logs In" | B{"Authentication Flow"};
    B -->| "Local (Username/Password)" | C["Auth Controller"];
    C -->| "Generate JWT" | D["utils.generateToken()"];
    D -->| "Set HTTP-Only Cookie" | E["Browser"];
    B -->| "Google OAuth" | F["Passport.js"];
    F -->| "Redirect to Google" | G["Google Auth Server"];
    G -->| "Callback with Profile" | F;
    F -->| "Find/Create User" | H["User Model"];
    H -->| "Serialize User ID" | I["Session (Passport)"];
    I -->| "User Authenticated" | E;
    E -->| "Subsequent Requests (JWT/Session)" | J["Protected Routes"];
```



### Friend Request Lifecycle

Friend interactions involve multiple steps handled by the `friend.controller.js`, modifying both sender and receiver `User` documents to reflect pending requests, established friendships, or rejections.





```mermaid
flowchart TD
    A["User 1: Requests Friend"] -->| "sendFriendRequest(User 2)" | B["friend.controller.js"];
    B -->| "Adds User 2 to 'sentRequests'" | C["User 1 Document"];
    B -->| "Adds User 1 to 'friendRequests'" | D["User 2 Document"];
    D --> E{"User 2 Action"};
    E -->| "Accept (acceptFriendRequest)" | F["friend.controller.js"];
    F -->| "Removes from 'friendRequests'" | D;
    F -->| "Removes from 'sentRequests'" | C;
    F -->| "Adds User 1 to 'friends'" | D;
    F -->| "Adds User 2 to 'friends'" | C;
    F --> G["Friends Established"];
    E -->| "Reject (rejectFriendRequest)" | H["friend.controller.js"];
    H -->| "Removes from 'friendRequests'" | D;
    H -->| "Removes from 'sentRequests'" | C;
    H --> I["Request Denied/Cancelled"];
```



Next: [Frontend Implementation and UI](./3_frontend-implementation-ui.mdx)