---
title: "Frontend State Management"
description: "Overview of the state management solution using Zustand."
---

# Frontend State Management

<TOC />

This document details the frontend state management strategy employed in this application, leveraging the Zustand library.  Zustand is chosen for its simplicity, ease of use, and minimal overhead, making it ideal for managing application state in a straightforward manner.  The application's state is divided into three distinct stores: `useAuthStore`, `useChatStore`, and `useThemeStore`. Each store manages a specific aspect of the application's functionality, promoting modularity and maintainability.


## 1.  Authentication Store (`useAuthStore.js`) [Source](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/store/useAuthStore.js)

The `useAuthStore` manages the authentication state of the user, including user information, login/signup status, and socket connection.  It utilizes asynchronous functions to interact with the backend API for authentication operations.

### 1.1 Store Structure

The store maintains the following state variables:

*   `authUser`: Stores the currently authenticated user object (null if not logged in).
*   `isSigningUp`, `isLoggingIn`, `isUpdatingProfile`, `isCheckingAuth`: Boolean flags indicating the loading state of respective operations.
*   `onlineUsers`: An array of online user IDs.
*   `socket`: The Socket.IO client instance.


```javascript
export const useAuthStore = create((set, get) => ({
    authUser: null,
    isSigningUp: false,
    isLoggingIn: false,
    isUpdatingProfile: false,
    isCheckingAuth: true,
    onlineUsers: [],
    socket: null,
    // ... other functions
}));
```

### 1.2 Key Functions

*   **`checkAuth()`**: Verifies user authentication status upon application load.
*   **`signup()`**: Handles user signup, updates state, and provides feedback using `react-hot-toast`.
*   **`login()`**: Handles user login, similar to signup.
*   **`logout()`**: Handles user logout, clearing the `authUser` state and disconnecting the socket.
*   **`updateProfile()`**: Handles profile updates.
*   **`connectSocket()`**: Establishes a Socket.IO connection, passing the user ID for identification.
*   **`disconnectSocket()`**: Disconnects the Socket.IO connection.

### 1.3  Asynchronous Operations and Error Handling

All API interactions are handled asynchronously using `async/await`, enhancing code readability and error handling.  Error responses from the server are caught and presented to the user via `react-hot-toast`.  `try...catch...finally` blocks ensure that loading flags are correctly updated regardless of success or failure.


```javascript
    signup: async (data) => {
        set({ isSigningUp: true });
        try {
            const res = await axiosInstance.post("/auth/signup", data);
            set({ authUser: res.data });
            toast.success("Account created successfully");
            get().connectSocket();
        } catch (error) {
            toast.error(error.response.data.message);
        } finally {
            set({ isSigningUp: false });
        }
    },
```

## 2. Chat Store (`useChatStore.js`) [Source](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/store/useChatStore.js)

The `useChatStore` manages the chat-related state, including messages, user lists, friend requests, and the currently selected user for chat.


### 2.1 State Variables

The store's state includes:

*   `messages`: An array of chat messages.
*   `users`: An array of the user's friends.
*   `pendingRequests`: An array of pending friend requests.
*   `sentRequests`: An array of sent friend requests.
*   `selectedUser`: The currently selected user for chatting (null if none).
*   `isUsersLoading`, `isMessagesLoading`: Boolean flags for loading states.
*   `isFriendBoxOpen`: Boolean to control the visibility of the friends box.

### 2.2 Core Functions

The store provides functions to:

*   Fetch and manage friend lists (`getFriends`, `getPendingRequests`, `getSentRequests`).
*   Manage friend requests (`sendFriendRequest`, `acceptFriendRequest`, `rejectFriendRequest`, `removeFriend`).
*   Fetch and manage chat messages (`getMessages`, `sendMessage`).
*   Subscribe and unsubscribe to real-time message updates via Socket.IO (`subscribeToMessages`, `unsubscribeFromMessages`).
*   Control the selection of a user for chat (`setSelectedUser`).
*   Control the visibility of the friends box (`toggleFriendsBox`).


```javascript
    sendMessage: async (messageData) => {
        const {selectedUser, messages} = get();
        try {
            const res = await axiosInstance.post(`/messages/send/${selectedUser._id}`, messageData);
            set({messages : [...messages, res.data]});
        } catch (error){
            toast.error(error.response.data.message);
        }
    },
```

### 2.3  Socket.IO Integration

The `subscribeToMessages` and `unsubscribeFromMessages` functions leverage the socket instance from `useAuthStore` to handle real-time message updates, efficiently updating the chat interface without requiring constant polling.  This improves performance and user experience.



## 3. Theme Store (`useThemeStore.js`) [Source](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/store/useThemeStore.js)

This simple store manages the application's theme (dark or light).  It uses `localStorage` to persist the selected theme across sessions.


```javascript
export const useThemeStore = create((set) => ({
    theme: localStorage.getItem("chat-theme") || "dark",
    setTheme: (theme) => {
        localStorage.setItem("chat-theme", theme);
        set({theme});
    }
}))
```


## 4.  Store Interactions and Data Flow

The three stores work independently but interact indirectly.  For example, `useChatStore` uses `useAuthStore` to access the socket connection for real-time message updates.  This dependency is managed by directly importing `useAuthStore` into `useChatStore`.

`

```mermaid
graph TD
    A[useAuthStore] --> B(Socket.IO Connection);
    A --> C{API Calls (Auth)};
    D[useChatStore] --> A;
    D --> E{API Calls (Chat)};
    D --> B;
    F[useThemeStore] --> G[localStorage];

```




## 5.  Overall Architecture

The chosen state management strategy promotes a modular, scalable, and easily maintainable application. The use of Zustand simplifies state management and reduces boilerplate. The separation of concerns across the stores enhances code organization and testability.

`

```mermaid
graph TD
    A[Frontend] --> B(useAuthStore);
    A --> C(useChatStore);
    A --> D(useThemeStore);
    B --> E[Backend API (Auth)];
    C --> F[Backend API (Chat)];
    B --> G[Socket.IO Server];
    C --> G;
```



Next: [Deployment and Setup](./4_deployment.mdx)