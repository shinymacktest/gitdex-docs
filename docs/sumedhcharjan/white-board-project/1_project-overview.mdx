---
title: "Project Overview"
description: "Provides a high-level understanding of the Whiteboard project and its purpose."
sidebar_position: 1
---

# Project Overview

The Collaborative Whiteboard project is a real-time application that enables multiple users to draw, share images, and collaborate seamlessly. Built using the MERN (MongoDB, Express.js, React.js, Node.js) stack, it leverages Socket.io for real-time bidirectional communication, Cloudinary for image storage, and JWT for user authentication.

## Key Features

*   **Real-time Drawing:** Collaborative drawing with multiple users.
*   **Image Upload:** Upload and share images via Cloudinary.
*   **User Authentication:** Secure login/register with JWT.
*   **Multi-user Support:** Multiple users can draw simultaneously.
*   **Drawing Tools:** Pen, eraser, shapes, colors, and brush sizes.
*   **Save Boards:** Save and retrieve whiteboard sessions.
*   **Responsive Design:** Works on desktop and mobile devices.
*   **Real-time Sync:** Instant synchronization across all connected clients.

## Technology Stack

| Technology    | Description                                          |
| :------------ | :--------------------------------------------------- |
| React.js      | Frontend UI library                                  |
| Node.js       | Backend runtime environment                          |
| Express.js    | Backend web framework                                |
| MongoDB       | Database for user data and board sessions           |
| Socket.io     | Real-time communication library                      |
| JWT           | User authentication and authorization              |
| Cloudinary    | Image upload and storage                             |

## Getting Started

### Prerequisites

Ensure you have the following installed:

*   [Node.js](https://nodejs.org/) (v14 or higher)
*   [MongoDB](https://www.mongodb.com/) (local or cloud)
*   [Git](https://git-scm.com/)

### Cloning the Repository

Clone the project repository:

```bash
git clone https://github.com/kalpm1110/whiteboard-project.git
cd whiteboard-project
```

### Configuring Environment Variables

Create a `.env` file in the root directory with the following variables:

```plaintext
# Database
MONGODB_URI=mongodb://localhost:27017/whiteboard
# or use MongoDB Atlas: mongodb+srv://username:password@cluster.mongodb.net/whiteboard

# JWT Secret
JWT_SECRET=your_super_secret_jwt_key_here

# Cloudinary Configuration
CLOUDINARY_CLOUD_NAME=your_cloudinary_cloud_name
CLOUDINARY_API_KEY=your_cloudinary_api_key
CLOUDINARY_API_SECRET=your_cloudinary_api_secret

# Server Configuration
PORT=5000
NODE_ENV=development

# Frontend URL (for CORS)
CLIENT_URL=http://localhost:3000
```

This `.env` file, crucial for configuring the application, houses sensitive information such as database URIs, JWT secrets, and API keys for Cloudinary. Storing these details as environment variables ensures that they are kept separate from the codebase, enhancing security and flexibility across different deployment environments.

### Installation and Running the Application

Install dependencies and start the application:

```bash
# Install backend dependencies
npm install

# Install frontend dependencies
cd client
npm install
cd ..

# Start both backend and frontend concurrently
npm run dev

# Or start them separately:
# Backend only
npm run server

# Frontend only (in another terminal)
cd client
npm start
```

The application will be available at:

*   Frontend: `http://localhost:3000`
*   Backend: `http://localhost:5000`

## Backend Structure

The backend, built with Node.js and Express.js, handles API requests, database interactions, and real-time communication via Socket.io.

```javascript
// backend/src/index.js
import express from 'express';
import http from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import dotenv from 'dotenv';
import mongoose from 'mongoose';

dotenv.config();

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
    cors: {
        origin: process.env.CLIENT_URL,
        methods: ["GET", "POST"]
    }
});

app.use(cors({ origin: process.env.CLIENT_URL }));
app.use(express.json());

// ... API routes and Socket.io logic

const PORT = process.env.PORT || 5000;

mongoose.connect(process.env.MONGODB_URI)
    .then(() => {
        console.log('Connected to MongoDB');
        server.listen(PORT, () => console.log(`Server running on port ${PORT}`));
    })
    .catch(err => console.error('MongoDB connection error:', err));
```

[View on GitHub](https://github.com/sumedhcharjan/white-board-project/blob/main/backend/src/index.js)

This code sets up the Express server, configures CORS to allow requests from the frontend, and establishes a connection to the MongoDB database using Mongoose. The Socket.io server is integrated to handle real-time events.

## Frontend Structure

The frontend, built with React.js, provides the user interface for the collaborative whiteboard. It communicates with the backend via API calls and Socket.io for real-time updates.

```javascript
// frontend/src/App.jsx
import React, { useState, useRef, useEffect } from 'react';
import io from 'socket.io-client';

function App() {
  const [socket, setSocket] = useState(null);
  const canvasRef = useRef(null);

  useEffect(() => {
    const newSocket = io('http://localhost:5000');
    setSocket(newSocket);

    return () => newSocket.close();
  }, [setSocket]);

  // ... drawing logic and event handlers

  return (
    <div>
      <canvas ref={canvasRef} />
    </div>
  );
}

export default App;
```

[View on GitHub](https://github.com/sumedhcharjan/white-board-project/blob/main/frontend/src/App.jsx)

This component initializes the Socket.io connection and sets up the canvas element for drawing. It also includes the necessary logic for handling drawing events and communicating with the backend.

## API Endpoints

| Route                   | Description                     |
| :---------------------- | :------------------------------ |
| `POST /api/auth/register` | Register a new user           |
| `POST /api/auth/login`    | Authenticate user             |
| `GET /api/auth/verify`    | Verify JWT token              |
| `POST /api/boards`        | Create a new whiteboard       |
| `GET /api/boards/:id`     | Get whiteboard by ID          |
| `PUT /api/boards/:id`     | Update whiteboard data        |
| `POST /api/upload`        | Upload image to Cloudinary    |

### Example: Image Upload Endpoint

```javascript
// backend/src/routes/upload.js
import express from 'express';
import cloudinary from '../utils/cloudinary.js';
import multer from 'multer';

const router = express.Router();
const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

router.post('/', upload.single('file'), async (req, res) => {
  try {
    const file = req.file;
    if (!file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const result = await cloudinary.uploader.upload(file.buffer.toString('base64'), {
      resource_type: 'image',
      folder: 'whiteboard'
    });

    res.status(200).json({
      message: 'Image uploaded successfully',
      imageUrl: result.secure_url,
      publicId: result.public_id
    });
  } catch (error) {
    console.error('Error uploading image to Cloudinary:', error);
    res.status(500).json({ message: 'Failed to upload image', error: error.message });
  }
});

export default router;
```

[View on GitHub](https://github.com/sumedhcharjan/white-board-project/blob/main/backend/src/routes/upload.js)

This code defines an endpoint for uploading images to Cloudinary. It uses `multer` middleware to handle file uploads and the Cloudinary API to store the images. Upon successful upload, it returns the URL and public ID of the image.

### Example: User Authentication (Registration)

```javascript
// backend/src/routes/auth.js
import express from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import User from '../models/User.js';

const router = express.Router();

router.post('/register', async (req, res) => {
  try {
    const { username, email, password } = req.body;
    const hashedPassword = await bcrypt.hash(password, 10);

    const newUser = new User({
      username,
      email,
      password: hashedPassword,
    });

    const savedUser = await newUser.save();
    const token = jwt.sign({ userId: savedUser._id }, process.env.JWT_SECRET, { expiresIn: '1h' });

    res.status(201).json({ message: "User registered successfully", token, user: { id: savedUser._id, username: savedUser.username, email: savedUser.email } });
  } catch (error) {
    console.error('Error registering user:', error);
    res.status(500).json({ message: "Failed to register user", error: error.message });
  }
});

export default router;
```

[View on GitHub](https://github.com/sumedhcharjan/white-board-project/blob/main/backend/src/routes/auth.js)

This code handles user registration, hashing the password with bcrypt before saving it to the database. It also generates a JWT token for the new user, which is sent back in the response.

## Socket.io Events

| Event            | Description                                      |
| :--------------- | :----------------------------------------------- |
| `join-room`      | Join a specific whiteboard room                  |
| `drawing`        | Send drawing data to other users                  |
| `clear-canvas`   | Clear the entire canvas                           |
| `image-upload`   | Share uploaded image with room                   |
| `cursor-position`| Share cursor position with others                |

### Example: Handling Drawing Events

```javascript
// backend/src/index.js
io.on('connection', (socket) => {
  socket.on('join-room', (roomId) => {
    socket.join(roomId);
  });

  socket.on('drawing', (data) => {
    socket.broadcast.to(data.roomId).emit('drawing', data);
  });

  // ... other event handlers
});
```

[View on GitHub](https://github.com/sumedhcharjan/white-board-project/blob/main/backend/src/index.js)

This code shows how the backend handles drawing events. When a user draws on the canvas, the data is broadcasted to all other users in the same room, ensuring real-time synchronization.

## Data Flow





```mermaid
graph LR
    A["Frontend (React)"] -->|"User Interaction"| B["Backend (Express)"];
    B -->|"API Request"| C["MongoDB"];
    B -->|"Socket.io"| A;
    A -->|"Socket.io"| B;
    B -->|"Image Upload"| D["Cloudinary"];
    D -->|"Image URL"| B;
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#ccf,stroke:#333,stroke-width:2px
    style C fill:#ccf,stroke:#333,stroke-width:2px
    style D fill:#ccf,stroke:#333,stroke-width:2px
```



This diagram illustrates the flow of data within the application. The frontend interacts with the backend via API requests and Socket.io. The backend communicates with MongoDB for data storage and Cloudinary for image uploads.

## Key Integration Points

### Socket.io Integration

Socket.io is crucial for real-time drawing and collaboration. The frontend emits drawing events to the backend, which then broadcasts these events to all other connected clients in the same room. This ensures that all users see the same drawing in real-time.

### Cloudinary Integration

Cloudinary is used for storing and serving images. When a user uploads an image, it is sent to Cloudinary, which returns a URL that can be used to display the image on the whiteboard. This simplifies image management and ensures that images are delivered efficiently.

### JWT Authentication

JWT (JSON Web Tokens) is used for user authentication and authorization. When a user registers or logs in, the backend generates a JWT token that is sent back to the frontend. The frontend then includes this token in subsequent requests to the backend, which verifies the token to ensure that the user is authenticated.

## Development Guidelines

*   Follow React best practices for frontend components.
*   Use meaningful variable and function names.
*   Add comments for complex drawing algorithms.
*   Test real-time functionality with multiple browser tabs.
*   Ensure mobile responsiveness for touch drawing.

```javascript
// Example: React Component Structure
function WhiteboardCanvas() {
  const [drawing, setDrawing] = useState(false);

  const startDrawing = () => {
    setDrawing(true);
  };

  const stopDrawing = () => {
    setDrawing(false);
  };

  const draw = (event) => {
    if (!drawing) return;
    // Drawing logic here
  };

  return (
    <canvas
      onMouseDown={startDrawing}
      onMouseUp={stopDrawing}
      onMouseMove={draw}
    />
  );
}
```

[View on GitHub](https://github.com/sumedhcharjan/white-board-project/blob/main/frontend/src/components/WhiteboardCanvas.jsx) (NOTE: Assuming a similar component exists or would be created).

This example shows a basic React component structure for handling drawing events on the canvas. The `startDrawing`, `stopDrawing`, and `draw` functions handle the mouse events and update the canvas accordingly.




```mermaid
graph TD
    A["User Action (e.g., Mouse Click)"] --> B{"Event Listener"};
    B --> C["Update State (e.g., drawing = true)"];
    C --> D["Canvas Rendering"];
    D --> E["Emit Socket Event"];
    E --> F["Backend"];
    F --> G["Broadcast to other users"];
    G --> H["Update Canvas on other clients"];
```


This diagram illustrates how real time interaction happen from user action to rendering on the canvas and then how it broadcasts using socket io.
```javascript
// Example: Socket.io Event Emission
socket.emit('drawing', {
  x: event.clientX,
  y: event.clientY,
  color: 'black',
  size: 5,
  roomId: 'currentRoomId'
});
```

[View on GitHub](https://github.com/sumedhcharjan/white-board-project/blob/main/frontend/src/utils/socket-utils.js) (NOTE: Assuming a similar utility file exists)

This code snippet demonstrates how the frontend emits a Socket.io event when the user draws on the canvas. The event includes the coordinates, color, size, and room ID, which are used by the backend to broadcast the drawing to other users in the same room.

By following these guidelines and best practices, you can contribute to the Collaborative Whiteboard project and help improve its functionality and usability.
```
```