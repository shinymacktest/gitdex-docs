---
title: "User Interface & Components"
description: "Breakdown of the main UI components, their purpose, and how they interact."
sidebar_position: 31
---

# User Interface & Components

<TOC />

This section delves into the core user interface components of the ShinyChat application, examining their individual responsibilities, how they interact, and their contribution to the overall user experience. The design prioritizes modularity, reusability, and efficient state management using Zustand for a responsive chat application.

## 3.1.1. Application Header: `Navbar.jsx`

The `Navbar` component provides persistent navigation and access to global application features. It is designed to be fixed at the top, offering consistent access points regardless of the current view.

**Purpose:**
- Global navigation to home, profile, and settings.
- Displays the application logo and title.
- Provides authentication-related actions like logout.
- Toggles the visibility of the friends list (sidebar) for smaller screens.

**Key Features:**
- **Branding:** Displays "ShinyChat" with an icon for brand recognition.
- **Navigation Links:** `Link` components from `react-router-dom` are used for client-side routing to `/`, `/settings`, and `/profile`.
- **Friends Toggle:** A button that leverages `useChatStore`'s `toggleFriendsBox` action to manage the visibility of the sidebar, particularly useful on mobile.
- **User Authentication Status:** Dynamically renders "Profile" and "Logout" buttons based on the `authUser` state from `useAuthStore`, ensuring that authenticated user actions are only visible when logged in.
- **Styling:** Uses Tailwind CSS classes combined with DaisyUI components (`btn`, `btn-sm`) for a modern, responsive look.

**Code Snippet: Navbar Structure**
```jsx
// frontend/src/components/Navbar.jsx
import { Link } from "react-router-dom";
import { useAuthStore } from "../store/useAuthStore";
import { LogOut, MessageSquare, Settings, User, Users } from "lucide-react";
import { useChatStore } from "../store/useChatStore";

const Navbar = () => {
  const { logout, authUser } = useAuthStore();
  const { toggleFriendsBox } = useChatStore(); 

  return (
    <header
      className=" bg-base-100 border-b border-base-300 fixed w-full top-0 z-40
        backdrop-blur-lg bg-base-100/80"
    >
      <div className="container mx-auto px-4 h-16">
        <div className="flex items-center justify-between h-full">
          <div className="flex items-center gap-8">
            <Link
              to="/"
              className="flex items-center gap-2.5 hover:opacity-80 transition-all"
            >
              <div className="size-9 rounded-lg bg-primary/10 flex items-center justify-center">
                <MessageSquare className="size-5 text-primary"></MessageSquare>
              </div>
              <h1 className="text-lg font-bold">ShinyChat</h1>
            </Link>
          </div>
          <div className="flex items-center gap-4">
            <button className="btn btn-sm gap-2" onClick={toggleFriendsBox}>
              <Users className="size-5" />
              <span className="hidden sm:inline">Friends</span>
            </button>
            <Link to={"/settings"}
            className={`btn btn-sm gap-2 transition-colors`}>
            <Settings className="size-4"/>
            <span className="hidden sm:inline">Settings</span>

            </Link>
            {authUser && (
              <>
                <Link to={"/profile"} className={`btn btn-sm gap-2`}>
                  <User className="size-5" />
                  <span className="hidden sm:inline">Profile</span>
                </Link>

                <button className="btn btn-sm flex gap-2 items-center" onClick={logout}>
                  <LogOut className="size-5" />
                  <span className="hidden sm:inline">Logout</span>
                </button>
              </>
            )}
          </div>
        </div>
      </div>
    </header>
  );
};

export default Navbar;
```
[[frontend/src/components/Navbar.jsx#L1-L71](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Navbar.jsx#L1-L71)]

## 3.1.2. User List Sidebar: `Sidebar.jsx`

The `Sidebar` component displays a list of friends or potential chat partners. It's designed to be dynamic, showing online/offline status and allowing users to filter by online status.

**Purpose:**
- Display a list of all registered users or friends.
- Indicate online/offline status for each user.
- Allow selection of a user to initiate or continue a chat.
- Provide a filter to show only online users.

**Key Features:**
- **Dynamic User Fetching:** Utilizes `useChatStore`'s `getFriends` action to fetch the list of users upon component mount, ensuring the list is always up-to-date.
- **Online Status Indicator:** Integrates with `useAuthStore` to get `onlineUsers` and displays a green dot for online users, enhancing real-time awareness.
- **User Selection:** Clicking a user in the sidebar calls `setSelectedUser` from `useChatStore`, which updates the global state and triggers the `ChatContainer` to load messages for that user.
- **Conditional Visibility:** The sidebar's visibility adapts based on whether a user is `selectedUser`, hiding itself on smaller screens when a chat is active to maximize chat real estate.
- **Online Filter:** A checkbox allows users to narrow down the list to only display currently online individuals.
- **Skeleton Loading:** Displays `SidebarSkeleton` while user data is being fetched, providing a better user experience.

**Code Snippet: Sidebar User List Rendering**
```jsx
// frontend/src/components/Sidebar.jsx
// ... (imports)

const Sidebar = () => {
    const { getFriends, users, selectedUser, setSelectedUser, isUsersLoading } =
        useChatStore();

    const { onlineUsers } = useAuthStore();
    const [showOnlineOnly, setShowOnlineOnly] = useState(false);
    useEffect(() => {
        getFriends();
    }, [getFriends]);
    const filteredUsers = showOnlineOnly
        ? users.filter((user) => onlineUsers.includes(user._id))
        : users;
    if (isUsersLoading) return <SidebarSkeleton />;
    return (
        <div className={`h-full sm:w-72 sm:border-r border-base-300  flex-col transition-all duration-200 ${selectedUser ?
                                    "hidden sm:flex w-[100vw] "
                                    : ""}`}>
            {/* ... (header, online toggle) */}
            <div className="overflow-y-scroll h-[calc(100vh-14rem)] w-full flex flex-col py-3">
                {filteredUsers.map((user) => (
                    <button
                        key={user._id}
                        onClick={() => setSelectedUser(user)}
                        className={`sm:w-full w-[88vw] p-3 flex items-center gap-3 hover:bg-base-300 transition-colors
                        ${
                            selectedUser?._id === user._id
                                ? "bg-base-300 ring-1 ring-base-300"
                                : ""
                        }`}
                    >
                        <div className="relative mx-0">
                            <img
                                src={user.profilePic || "/avatar.png"}
                                alt={user.username}
                                className="size-12 object-cover rounded-full"
                            />
                            {onlineUsers.includes(user._id) && (
                                <span className="absolute bottom-0 right-0 size-3 bg-green-500 rounded-full ring-2 ring-zinc-900" />
                            )}
                        </div>
                        <div className=" block text-left min-w-0">
                            <div className=" font-medium truncate">
                                {user.username}
                            </div>
                            <div className="text-sm text-zinc-400">
                                {onlineUsers.includes(user._id)
                                    ? "Online"
                                    : "Offline"}
                            </div>
                        </div>
                    </button>
                ))}
            </div>
            {/* ... (empty state) */}
        </div>
    );
};

export default Sidebar;
```
[[frontend/src/components/Sidebar.jsx#L1-L76](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Sidebar.jsx#L1-L76)]

## 3.1.3. Chat Interface: `ChatContainer.jsx`

The `ChatContainer` is the central component for displaying messages and interacting within a chat. It handles message fetching, real-time updates, and rendering of individual messages.

**Purpose:**
- Display all messages exchanged between the authenticated user and the `selectedUser`.
- Provide real-time updates for new messages.
- Handle initial message loading and show a loading skeleton.
- Automatically scroll to the latest message.

**Key Features:**
- **Message Loading:** On `selectedUser` change, `getMessages` is called from `useChatStore` to fetch the chat history.
- **Real-time Messaging:** `subscribeToMessages` and `unsubscribeFromMessages` manage a WebSocket connection for real-time message reception, ensuring that new messages appear instantly without requiring a page refresh. This leverages Socket.IO, although the direct Socket.IO setup is managed within the Zustand store.
- **Scroll to Bottom:** A `useRef` hook (`messageEndRef`) and an `useEffect` automatically scroll the chat view to the latest message whenever new messages are added.
- **Message Rendering:** Iterates through the `messages` array, displaying each message with the sender's profile picture, timestamp, and content (text or image).
- **User Identification:** Messages are styled as "chat-end" (sent by `authUser`) or "chat-start" (sent by `selectedUser`), providing visual cues about who sent which message.
- **Image Support:** Displays inline images if a message contains an `image` URL.
- **Skeleton Loading:** During message retrieval, `MessageSkeleton` is rendered to indicate loading state.

**Code Snippet: ChatContainer Message Rendering**
```jsx
// frontend/src/components/ChatContainer.jsx
// ... (imports)

const ChatContainer = () => {
    const { messages, getMessages, isMessagesLoading, selectedUser, subscribeToMessages, unsubscribeFromMessages } =
        useChatStore();
    const { authUser } = useAuthStore();
    const messageEndRef = useRef(null);

    useEffect(() => {
        getMessages(selectedUser._id);
        subscribeToMessages();

        return () => unsubscribeFromMessages();
    }, [selectedUser._id, getMessages, subscribeToMessages, unsubscribeFromMessages]);
    
    useEffect(() => {
        if(messageEndRef.current && messages){
            messageEndRef.current.scrollIntoView({behaviour : "smooth"})
        }
    }, [messages])

    if (isMessagesLoading)
        return (
            <div className="flex-1 flex flex-col overflow-auto">
                <ChatHeader />
                <MessageSkeleton />
                <MessageInput />
            </div>
        );
    return (
        <div className="flex-1 flex flex-col overflow-auto">
            <ChatHeader />
            <div className="flex-1 overflow-y-auto p-4 space-y-4">
                {messages.map((message) => (
                    <div
                        key={message._id}
                        className={`chat ${message.senderId == authUser._id ? "chat-end": "chat-start"} `}
                        ref={messageEndRef}
                    >
                        <div className="chat-image avatar">
                            <div className="size-9 rounded-full border">
                                <img
                                    src={message.senderId == authUser._id ? authUser.profilePic || "/avatar.png": selectedUser.profilePic || "/avatar.png"}
                                    alt="profilepic"
                                 />
                            </div>
                        </div>
                        <div className="chat-header mb-1">
                            <time className="text-xs opacity-50 ml-1">{formatMessageTime(message.createdAt)}</time>
                        </div>
                        <div className="chat-bubble flex flex-col">
                            {message.image && (
                                <img 
                                    src={message.image}
                                    alt="Attachment"
                                    className="sm:max-w-[200px] rounded-md " 
                                />
                            )}
                            {message.text && <p>{message.text}</p>}
                        </div>
                    </div>
                ))}
            </div>
            <MessageInput />
        </div>
    );
};

export default ChatContainer;
```
[[frontend/src/components/ChatContainer.jsx#L1-L75](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/ChatContainer.jsx#L1-L75)]

## 3.1.4. Message Input: `MessageInput.jsx`

The `MessageInput` component allows users to compose and send text messages and attach images. It is a critical part of the `ChatContainer`.

**Purpose:**
- Provide an input field for typing messages.
- Allow users to attach and preview images before sending.
- Handle message submission.

**Key Features:**
- **Text Input:** Manages the text content of the message using local state (`useState`).
- **Image Attachment:**
    - Uses a hidden file input triggered by a custom button.
    - Previews selected images using `FileReader`, ensuring the user sees what they're sending.
    - Validates file type to ensure only images are selected.
    - Provides a "remove image" button (`X` icon) to clear the preview.
- **Message Sending:** On form submission, calls `sendMessage` from `useChatStore` with the text and image data. This action handles the API call to send the message to the backend.
- **Input Reset:** Clears the text input and image preview after a successful send.
- **Error Handling:** Uses `react-hot-toast` to display user-friendly error messages, e.g., if a non-image file is selected.
- **Disabled State:** The send button is disabled if both the text input and image preview are empty, preventing empty messages from being sent.

**Code Snippet: Message Input & Image Handling**
```jsx
// frontend/src/components/MessageInput.jsx
import { useRef, useState } from "react";
import { useChatStore } from "../store/useChatStore";
import { Image, Send, X } from "lucide-react";
import toast from "react-hot-toast";

const MessageInput = () => {
    const [text, setText] = useState("");
    const [imagePreview, setImagePreview] = useState(null);
    const fileInputRef = useRef(null);
    const { sendMessage } = useChatStore();

    const handleImageChange = (e) => {
        const file = e.target.files[0];
        if (!file.type.startsWith("image/")) {
            toast.error("Please select an image file");
            return;
        }

        const reader = new FileReader();
        reader.onloadend = () => {
            setImagePreview(reader.result);
        };
        reader.readAsDataURL(file);
    };

    const removeImage = () => {
        setImagePreview(null);
        if (fileInputRef.current) fileInputRef.current.value = "";
    };

    const handleSendMessage = async (e) => {
        e.preventDefault();
        if (!text.trim() && !imagePreview) return;

        try {
            await sendMessage({
                text: text.trim(),
                image: imagePreview,
            });

            setText("");
            setImagePreview(null);
            if (fileInputRef.current) fileInputRef.current = "";
        } catch (error) {
            console.error("Failed to send message", error);
        }
    };

    return (
        <div className="p-4 w-full">
            {imagePreview && (
                <div className="mb-3 flex items-center gap-2">
                    <div className="relative">
                        <img
                            src={imagePreview}
                            alt="Preview"
                            className="w-20 h-20 object-cover rounded-lg border border-zinc-700"
                        />
                        <button
                            onClick={removeImage}
                            className="absolute -top-1.5 -right-1.5 w-5 h-5 rounded-full bg-base-300
              flex items-center justify-center"
                            type="button"
                        >
                            <X className="size-3" />
                        </button>
                    </div>
                </div>
            )}

            <form
                onSubmit={handleSendMessage}
                className="flex items-center gap-2"
            >
                <div className="flex flex-1 gap-2">
                    <input
                        type="text"
                        className="w-full input input-bordered rounded-lg input-sm sm:input-md"
                        placeholder="Type a message..."
                        value={text}
                        onChange={(e) => setText(e.target.value)}
                    />
                    <input
                        type="file"
                        accept="image/*"
                        className="hidden"
                        ref={fileInputRef}
                        onChange={handleImageChange}
                    />

                    <button
                        type="button"
                        className={`hidden sm:flex btn btn-circle
                            ${
                                imagePreview
                                    ? "text-emerald-500"
                                    : "text-zinc-400"
                            }`}
                        onClick={
                            () => {
                                if (fileInputRef.current) {
                                    fileInputRef.current.click();
                                } else {
                                    console.error("fileInputRef is not attached");
                                }
                        }
                        }
                    >
                        <Image size={20} />
                    </button>
                </div>

                <button
                    type="submit"
                    className="btn btn-sm btn-circle"
                    disabled={!text.trim() && !imagePreview}
                >
                    <Send size={22} />
                </button>
            </form>
        </div>
    );
};

export default MessageInput;
```
[[frontend/src/components/MessageInput.jsx#L1-L127](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/MessageInput.jsx#L1-L127)]

## 3.1.5. Component Interaction Diagram

The following diagram illustrates how the main UI components interact with each other and with the Zustand stores for state management.





```mermaid
graph TD
    User --> Navbar[Navbar (Global Navigation)];
    User --> Sidebar[Sidebar (Friends List)];
    User --> ChatContainer[ChatContainer (Messages & Input)];

    Navbar --> useAuthStore[Zustand: useAuthStore (Auth User, Logout)];
    Navbar --> useChatStore[Zustand: useChatStore (Toggle Friends Box)];

    Sidebar --> useAuthStore;
    Sidebar --> useChatStore;
    useAuthStore -- authUser, onlineUsers --> Sidebar;
    useChatStore -- getFriends, users, selectedUser, setSelectedUser --> Sidebar;
    
    ChatContainer --> ChatHeader;
    ChatContainer --> MessageInput;
    ChatContainer --> useAuthStore;
    ChatContainer --> useChatStore;

    useChatStore -- messages, isMessagesLoading, subscribe/unsubscribe --> ChatContainer;
    useAuthStore -- authUser --> ChatContainer;
    MessageInput --> useChatStore;
    useChatStore -- sendMessage --> MessageInput;

    subgraph Stores
        useAuthStore;
        useChatStore;
    end
```



## 3.1.6. Key Insights and Best Practices

-   **State Management with Zustand:** The application leverages Zustand for efficient global state management. This approach ensures that components like `ChatContainer`, `Sidebar`, and `Navbar` can subscribe to and update shared states (e.g., `authUser`, `selectedUser`, `messages`, `onlineUsers`) without prop drilling, promoting cleaner code and better performance.
-   **Modularity and Reusability:** Each component has a single, well-defined responsibility. `MessageInput` is separated from `ChatContainer` to encapsulate input logic, making both components easier to understand, test, and maintain.
-   **Real-time Updates:** The integration with `useChatStore`'s `subscribeToMessages` highlights the use of WebSockets (Socket.IO) for delivering a truly interactive and real-time chat experience, crucial for modern messaging applications.
-   **Responsive Design:** The conditional rendering and utility-first CSS (Tailwind CSS with DaisyUI) ensure that the UI adapts gracefully across different screen sizes, with the sidebar collapsing on smaller devices when a chat is active.
-   **User Experience (UX) Enhancements:**
    *   **Loading Skeletons:** `MessageSkeleton` and `SidebarSkeleton` provide visual feedback during data fetching, reducing perceived loading times.
    *   **Auto-Scroll:** The `messageEndRef` and `useEffect` in `ChatContainer` ensure the latest messages are always in view, enhancing usability.
    *   **Image Previews:** In `MessageInput`, showing an image preview before sending improves user confidence and prevents accidental uploads.
-   **Separation of Concerns:** UI rendering logic is kept distinct from data fetching and state manipulation logic, which resides primarily in the Zustand stores. This separation improves code organization and simplifies debugging.

Next: [Pages & Routing](./3.2_pages_routing.mdx)