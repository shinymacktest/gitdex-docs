---
title: "Frontend State Management"
description: "How the application state is managed using Zustand."
---

# Frontend State Management

<TOC />

This document details the frontend state management strategy employed in this application, leveraging the Zustand library.  Zustand provides a simple, scalable solution for managing application state within React components.  We utilize it to manage authentication status, chat data, and theme preferences.

## Zustand Overview

Zustand is a small, fast, and scalable state-management solution. It uses a minimalistic approach, providing essential features without unnecessary complexity. Its core concept revolves around creating stores, which hold the application's state and provide functions for modifying it. These stores are easily integrated into React components using a hook-based system.

### Key Features of Zustand used in this application:

* **Simplicity:** Zustand's API is incredibly straightforward, making it easy to learn and use.
* **Immutability:**  State updates are handled immutably, preventing unexpected side effects and promoting easier debugging.
* **Performance:** Zustand is designed for performance, offering efficient state updates.
* **Integration with React:**  The hook-based approach seamlessly integrates with React's component lifecycle.

## Store Structure:

The application uses three separate Zustand stores:

* `useAuthStore`: Manages user authentication, including login, signup, logout, profile updates, and connection to a Socket.IO server.
* `useChatStore`: Handles chat-related data, including friend lists, pending requests, messages, and selected user.
* `useThemeStore`:  Manages the application's theme (light/dark).

````mermaid
graph TD
A[useAuthStore] --> B(authUser, isSigningUp, isLoggingIn, isUpdatingProfile, isCheckingAuth, onlineUsers, socket);
A --> C{checkAuth, signup, logout, login, updateProfile, connectSocket, disconnectSocket};
D[useChatStore] --> E(messages, users, pendingRequests, sentRequests, selectedUser, isUsersLoading, isMessagesLoading, isFriendBoxOpen);
D --> F{getFriends, getPendingRequests, getSentRequests, sendFriendRequest, acceptFriendRequest, rejectFriendRequest, removeFriend, getMessages, sendMessage, subscribeToMessages, unsubscribeFromMessages, setSelectedUser, toggleFriendsBox};
G[useThemeStore] --> H(theme);
G --> I{setTheme};
```

## useAuthStore: Authentication Management

This store manages the application's authentication state. It handles user login, signup, logout, profile updates, and manages the connection to a Socket.IO server for real-time updates.

```javascript
// frontend/src/store/useAuthStore.js [Source](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/store/useAuthStore.js)
import { create } from "zustand";
import { axiosInstance } from "../lib/axios";
// ... other imports

export const useAuthStore = create((set, get) => ({
    authUser: null,
    isSigningUp: false,
    // ... other state variables

    checkAuth: async () => {
        try {
            const res = await axiosInstance.get("/auth/check");
            set({ authUser: res.data });
            get().connectSocket();
        } catch (error) {
            set({ authUser: null });
            console.log("Error in checkAuth: ", error);
        } finally {
            set({ isCheckingAuth: false });
        }
    },

    // ... other actions (signup, logout, login, updateProfile, connectSocket, disconnectSocket)
}));
```

The `checkAuth` action fetches user authentication status from the backend, updates the `authUser` state, and connects to the socket if the user is authenticated.  Note the use of `try...catch...finally` for robust error handling.  The `get()` function allows accessing other parts of the store, enabling the connection/disconnection of the socket based on authentication status.


## useChatStore: Chat Functionality

This store manages all aspects related to chat, including retrieving and updating lists of friends, pending friend requests, sent requests, messages, and the currently selected user for chatting.

```javascript
// frontend/src/store/useChatStore.js [Source](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/store/useChatStore.js)
import { create } from "zustand";
import { axiosInstance } from "../lib/axios";
// ... other imports

export const useChatStore = create((set, get) => ({
    messages: [],
    users: [],
    // ... other state variables

    getFriends: async () => {
        set({ isUsersLoading: true });
        try {
            const res = await axiosInstance.get("/friends/list");
            set({ users: res.data });
        } catch (error) {
            toast.error(error.response?.data?.message || "Failed to fetch friends");
        } finally {
            set({ isUsersLoading: false });
        }
    },

    // ... other actions (getPendingRequests, getSentRequests, sendFriendRequest, acceptFriendRequest, rejectFriendRequest, removeFriend, getMessages, sendMessage, subscribeToMessages, unsubscribeFromMessages, setSelectedUser)
}));
```

The `getFriends` action demonstrates a typical pattern: setting a loading state (`isUsersLoading`), making an API call, updating the `users` state with the result, and handling potential errors.  Note the use of optional chaining (`?.`) and nullish coalescing (`||`) for safer error handling.

## useThemeStore: Theme Management

This simple store manages the application's theme, persisting the selection using `localStorage`.

```javascript
// frontend/src/store/useThemeStore.js [Source](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/store/useThemeStore.js)
import { create } from "zustand";

export const useThemeStore = create((set) => ({
    theme: localStorage.getItem("chat-theme") || "dark",
    setTheme: (theme) => {
        localStorage.setItem("chat-theme", theme);
        set({ theme });
    }
}));
```

This store demonstrates the simplicity of Zustand.  It directly accesses and modifies `localStorage` for persistent theme storage.


## Socket.IO Integration

The `useAuthStore` integrates with Socket.IO for real-time updates on online users and new messages.  The `connectSocket` and `disconnectSocket` actions handle the connection and disconnection to the server.  The `useChatStore` subscribes and unsubscribes to the "newMessage" event using the socket from `useAuthStore`.

````mermaid
sequenceDiagram
    participant Client
    participant Socket.IO Server
    participant useAuthStore
    participant useChatStore

    Client->>useAuthStore: Connects
    activate useAuthStore
    useAuthStore->>Socket.IO Server: connect
    Socket.IO Server-->>useAuthStore: connection established
    deactivate useAuthStore

    Client->>useChatStore: Selects User
    activate useChatStore
    useChatStore->>useAuthStore: Get Socket
    useAuthStore-->>useChatStore: Socket
    useChatStore->>Socket.IO Server: Subscribe to "newMessage"
    Socket.IO Server-->>useChatStore: newMessage event
    deactivate useChatStore

```


Next: [Deployment and Setup](./4_deployment_setup.mdx)