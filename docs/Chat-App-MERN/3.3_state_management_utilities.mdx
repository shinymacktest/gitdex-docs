```mdx
---
title: "State Management & Utilities"
description: "Overview of Zustand for state management and common utility functions for frontend operations."
sidebar_position: 33
---

import { Tabs, Tab } from 'nextra-theme-docs';

# State Management & Utilities

<TOC />

This section delves into the frontend's approach to state management using Zustand and essential utility functions. It covers how user authentication, chat interactions, and network requests are handled, emphasizing a reactive and efficient architecture.

## Zustand for Reactive State Management

Zustand is a lightweight, fast, and scalable state management solution used across the frontend. Its simplicity allows for global state slices without boilerplate, making it ideal for managing complex application states like authentication status, chat messages, and user lists.

### `useAuthStore` - Managing User Authentication and Socket Connections

The [`useAuthStore.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/store/useAuthStore.js) file defines the core authentication logic, user session management, and real-time connectivity via Socket.IO.

#### Key State Properties

| Property           | Type      | Description                                                    | Initial Value |
| :----------------- | :-------- | :------------------------------------------------------------- | :------------ |
| `authUser`         | `Object`  | Stores the currently authenticated user's data.                | `null`        |
| `isSigningUp`      | `boolean` | Indicates if a signup operation is in progress.                | `false`       |
| `isLoggingIn`      | `boolean` | Indicates if a login operation is in progress.                 | `false`       |
| `isUpdatingProfile`| `boolean` | Indicates if a profile update operation is in progress.        | `false`       |
| `isCheckingAuth`   | `boolean` | Indicates if the initial authentication check is in progress.  | `true`        |
| `onlineUsers`      | `Array`   | List of user IDs currently online, received via Socket.IO.     | `[]`          |
| `socket`           | `Socket`  | The Socket.IO client instance for real-time communication.     | `null`        |

#### Core Actions

The `useAuthStore` provides a suite of asynchronous actions for user lifecycle management:

-   **`checkAuth()`**: Verifies the user's authentication status with the backend. If authenticated, it sets `authUser` and initiates a Socket.IO connection.
-   **`signup(data)`**: Registers a new user. On success, sets `authUser` and connects the socket.
-   **`login(data)`**: Authenticates an existing user. On success, sets `authUser` and connects the socket.
-   **`logout()`**: Invalidates the user session, clears `authUser`, and disconnects the socket.
-   **`updateProfile(data)`**: Updates the authenticated user's profile information.

<Tabs>
<Tab title="checkAuth & Socket Connection">
```javascript filename="frontend/src/store/useAuthStore.js" {18-29}
export const useAuthStore = create((set, get) => ({
    authUser: null,
    isSigningUp: false,
    isLoggingIn: false,
    isUpdatingProfile: false,
    isCheckingAuth: true,
    onlineUsers: [],
    socket: null,

    checkAuth: async () => {
        try {
            const res = await axiosInstance.get("/auth/check");

            set({ authUser: res.data });

            get().connectSocket();
        } catch (error) {
            set({ authUser: null });
            console.log("Error in checkAuth: ", error);
        } finally {
            set({ isCheckingAuth: false });
        }
    },

    connectSocket: () => {
        const { authUser } = get();
        if(!authUser || get().socket?.connected) return;

        const socket = io(BASE_URL, {
            query: {
                userId : authUser._id,
            },
        });
        socket.connect();
        set({socket: socket});

        socket.on("getOnlineUsers", (userIds) => {
            set({onlineUsers: userIds})
        }); 

    },
    // ... other actions
}));
```
</Tab>
<Tab title="signup & login">
```javascript filename="frontend/src/store/useAuthStore.js" {31-59}
export const useAuthStore = create((set, get) => ({
    // ... state properties

    signup: async (data) => {
        set({ isSigningUp: true });
        try {
            const res = await axiosInstance.post("/auth/signup", data);
            set({ authUser: res.data });
            toast.success("Account created successfully");

            get().connectSocket();
        } catch (error) {
            toast.error(error.response.data.message);
            5;
        } finally {
            set({ isSigningUp: false });
        }
    },

    logout: async () => { /* ... */ }, // Snipped for brevity

    login: async (data) => {
        set({ isLoggingIn: true });
        try {
            const res = await axiosInstance.post("/auth/login", data);
            set({ authUser: res.data });
            get().connectSocket();
            toast.success("Logged in successfully");

        } catch (error) {
            toast.error(error.response.data.message);
        } finally {
            set({ isLoggingIn: false });
        }
    },
    // ... other actions
}));
```
</Tab>
</Tabs>

#### Socket.IO Integration

The `connectSocket` and `disconnectSocket` actions manage the WebSocket connection. `connectSocket` establishes a persistent connection upon user authentication, sending the `userId` as a query parameter for server-side identification. It subscribes to the `getOnlineUsers` event to keep the `onlineUsers` state updated, providing real-time presence indicators.





```mermaid
graph TD
    A[User Authenticates] --> B{checkAuth, signup, or login};
    B --> C{axiosInstance.get/post /auth/...};
    C --> D{Successful Response};
    D --> E[set authUser state];
    E --> F[get().connectSocket()];
    F --> G[New Socket.IO Connection];
    G --> H[Emit userId to server];
    H --> I{Server: Register User as Online};
    I --> J[socket.on("getOnlineUsers")];
    J --> K[Update onlineUsers state];
    F -.-> L[If authUser already exists or socket connected, skip];
```



**Key Insight**: By integrating Socket.IO directly into the authentication store, the application ensures that real-time features (like online status) are active only when a user is authenticated, promoting efficient resource usage and a cohesive user experience.

### `useChatStore` - Managing Chat and Friend Interactions

The [`useChatStore.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/store/useChatStore.js) file handles all aspects related to chat functionality, including managing messages, friend lists, and friend requests. It leverages `useAuthStore` to access the active socket connection for real-time message updates.

#### Key State Properties

| Property              | Type      | Description                                                    | Initial Value |
| :-------------------- | :-------- | :------------------------------------------------------------- | :------------ |
| `messages`            | `Array`   | List of messages in the currently selected chat.               | `[]`          |
| `users`               | `Array`   | List of friends of the authenticated user.                     | `[]`          |
| `pendingRequests`     | `Array`   | List of incoming friend requests.                              | `[]`          |
| `sentRequests`        | `Array`   | List of outgoing friend requests.                              | `[]`          |
| `selectedUser`        | `Object`  | The user currently selected for chatting.                      | `null`        |
| `isUsersLoading`      | `boolean` | Indicates if the friends list is being fetched.                | `false`       |
| `isMessagesLoading`   | `boolean` | Indicates if messages for a chat are being fetched.            | `false`       |
| `isFriendBoxOpen`     | `boolean` | Controls the visibility of a friend management UI component.   | `false`       |

#### Core Actions

`useChatStore` provides comprehensive actions for chat and friend management:

-   **`toggleFriendsBox()`**: Toggles the `isFriendBoxOpen` state.
-   **`getFriends()`**: Fetches the authenticated user's friends list.
-   **`getPendingRequests()`**: Retrieves incoming friend requests.
-   **`getSentRequests()`**: Retrieves outgoing friend requests.
-   **`sendFriendRequest(identifier)`**: Sends a friend request to another user.
-   **`acceptFriendRequest(senderId)`**: Accepts an incoming friend request.
-   **`rejectFriendRequest(senderId)`**: Rejects an incoming friend request.
-   **`removeFriend(friendId)`**: Removes a friend from the user's list.
-   **`getMessages(userId)`**: Fetches chat messages for a specific user.
-   **`sendMessage(messageData)`**: Sends a new message to the `selectedUser`.
-   **`subscribeToMessages()`**: Listens for `newMessage` events from the Socket.IO server and updates the `messages` state if the message is from the `selectedUser`.
-   **`unsubscribeFromMessages()`**: Removes the `newMessage` event listener.
-   **`setSelectedUser(user)`**: Sets the currently selected user for chat.

<Tabs>
<Tab title="Message & Friend Actions">
```javascript filename="frontend/src/store/useChatStore.js" {42-65}
export const useChatStore = create((set, get) => ({
    // ... state properties

    sendFriendRequest: async (identifier) => {
        try {
            const res = await axiosInstance.post("/friends/request/send", { identifier });
            toast.success(res.data.message);
            get().getSentRequests();
        } catch (error) {
            toast.error(error.response?.data?.message || "Failed to send request");
        }
    },
    acceptFriendRequest: async (senderId) => {
        try {
            const res = await axiosInstance.post(`/friends/request/accept/${senderId}`);
            toast.success(res.data.message);
            get().getFriends();
            get().getPendingRequests();
        } catch (error) {
            toast.error(error.response?.data?.message || "Failed to accept request");
        }
    },

    rejectFriendRequest: async (senderId) => { /* ... */ }, // Snipped
    removeFriend: async (friendId) => { /* ... */ }, // Snipped

    getMessages: async (userId) => {
        set({isMessagesLoading: true});
        try {
            const res = await axiosInstance.get(`/messages/${userId}`);
            set({messages: res.data});
        } catch (error) {
            toast.error(error.response.data.message);
        } finally {
            set({isMessagesLoading: false});
        }
    },
    sendMessage: async (messageData) => {
        const {selectedUser, messages} = get();
        try {
            const res = await axiosInstance.post(`/messages/send/${selectedUser._id}`, messageData);
            set({messages : [...messages, res.data]});
        } catch (error){
            toast.error(error.response.data.message);
        }

    },
    // ... other actions
}));
```
</Tab>
<Tab title="Real-time Message Subscription">
```javascript filename="frontend/src/store/useChatStore.js" {98-111}
export const useChatStore = create((set, get) => ({
    // ... state properties and other actions

    subscribeToMessages: () => {
        const { selectedUser } = get();
        if(!selectedUser) return;
        
        // Accessing socket from useAuthStore
        const socket = useAuthStore.getState().socket; 
        socket.on("newMessage", (newMessage) => {
            if(newMessage.senderId !== selectedUser._id) return
            set({
                messages: [...get().messages, newMessage]
            })
        })
    },

    unsubscribeFromMessages: () => {
        const socket = useAuthStore.getState().socket;
        socket.off("newMessage");
    },
    
    setSelectedUser: (selectedUser) => set({selectedUser})
}));
```
</Tab>
</Tabs>

**Key Integration Point**: `useChatStore` demonstrates how different Zustand stores can interact. It accesses the Socket.IO instance from `useAuthStore` using `useAuthStore.getState().socket`, ensuring a single, shared socket connection across the application. This promotes a clear separation of concerns while maintaining necessary inter-store communication.





```mermaid
graph TD
    A[useAuthStore] -->|Provides socket instance| B[useChatStore];
    B --> C[getFriends()];
    B --> D[getMessages(userId)];
    B --> E[sendMessage(messageData)];
    B --> F[subscribeToMessages()];
    F --> G{socket.on("newMessage")};
    G --> H{If senderId matches selectedUser._id};
    H --> I[Update messages state];
    C -.-> J[API: /friends/list];
    D -.-> K[API: /messages/:userId];
    E -.-> L[API: /messages/send/:userId];
```



## Axios Instance for API Communication

The [`axios.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/lib/axios.js) file configures a custom Axios instance, `axiosInstance`, for all HTTP requests to the backend. This centralized configuration ensures consistency and simplifies API interactions.

```javascript filename="frontend/src/lib/axios.js" {3-6}
import axios from "axios";

export const axiosInstance = axios.create({
    baseURL: import.meta.env.MODE == "development" ? "http://localhost:5001/api": "/api",
    withCredentials: true,
});
```

-   **`baseURL`**: Dynamically set based on the environment (`development` or `production`). This ensures requests are sent to the correct API endpoint, whether local or deployed.
-   **`withCredentials: true`**: Crucial for sending and receiving HTTP cookies (e.g., session tokens) across cross-origin requests. This is vital for maintaining user sessions and authentication state with the backend.

**Best Practice**: Using a dedicated Axios instance with pre-configured settings avoids repetitive configuration, centralizes request handling, and simplifies future modifications to API communication logic (e.g., adding interceptors for token refreshing or error handling).

## Utility Functions

The [`utils.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/lib/utils.js) file contains helper functions that provide reusable logic for common frontend operations.

### `formatMessageTime(date)`

This function formats a given date into a human-readable time string, including year, month, day, and 12-hour time with AM/PM indicator. This is particularly useful for displaying message timestamps in a consistent and user-friendly manner within the chat interface.

```javascript filename="frontend/src/lib/utils.js" {1-10}
export function formatMessageTime(date) {
    return new Date(date).toLocaleTimeString("en-US", {
        year: "numeric",
        month: "short",
        day:"2-digit",
        hour: "2-digit",
        minute: "2-digit",
        hour12: true,
    });
}
```

**Key Insight**: Utility functions promote code reusability and maintainability by encapsulating specific, common operations. This keeps components cleaner and focused on rendering UI.

## Summary of State and Utility Interactions

The state management and utility layers are fundamental to the frontend's functionality:

-   **Authentication Flow**: `useAuthStore` manages the user's session, integrating with `axiosInstance` for secure API calls and initiating `Socket.IO` for real-time presence.
-   **Chat & Friends Flow**: `useChatStore` handles all friend and chat-related data, also using `axiosInstance` for RESTful API calls and leveraging the `useAuthStore`'s socket for real-time message delivery.
-   **Error Handling**: Both Zustand stores utilize `react-hot-toast` for user feedback on API success or failure, ensuring a responsive user experience.
-   **Development vs. Production**: `axiosInstance` dynamically adjusts its `baseURL` based on `import.meta.env.MODE`, simplifying deployment to different environments.
-   **Time Formatting**: `formatMessageTime` ensures consistent and readable message timestamps, enhancing the chat UI.

The cohesive interaction between these components ensures a robust, scalable, and user-friendly chat application.

---

Next: [Styling & Configuration](./4_styling_configuration.mdx)
```