---
title: "Authentication & Authorization"
description: "Details the security mechanisms for user authentication and authorization across the MERN stack."
---

# Authentication & Authorization

<TOC />

This section details the robust security mechanisms implemented for user authentication and authorization within the MERN stack application. It covers traditional email/password login, Google OAuth integration, secure password hashing, and token-based authorization using JSON Web Tokens (JWTs).

## User Model (`backend/src/models/user.model.js`)

The `User` model is central to managing user data, including authentication-specific fields.

```javascript filename="backend/src/models/user.model.js"
import mongoose from "mongoose";

const userSchema = new mongoose.Schema(
    {
        username: {
            type: String,
            required: true,
            unique: true,
            minlength: 3,
            maxlength: 20
        },
        email: {
            type: String,
            required: true,
            unique: true,
        },
        password: {
            type: String,
            minlength: 6,
        },
        profilePic: {
            type: String,
            default: "",
        },
        googleId: { // Used for Google OAuth
            type: String,
            unique: true,
            sparse: true, // Allows multiple null values
        },
        authProvider: { // 'email' or 'google'
            type: String,
            enum: ['email', 'google'],
            default: 'email'
        }
    },
    { timestamps: true }
);

const User = mongoose.model("User", userSchema);

export default User;
```

<br />
<details>
<summary>Source Code: `backend/src/models/user.model.js`</summary>

```javascript
import mongoose from "mongoose"

const  userSchema = new mongoose.Schema(
    {
        email: { 
            type: String,
            required: true,
            unique: t
```
</details>

<br />

-   **`username`**: Unique identifier for users, with length constraints.
-   **`email`**: Unique email address for login.
-   **`password`**: Hashed password (only for 'email' authProvider).
-   **`profilePic`**: URL to the user's profile picture.
-   **`googleId`**: Stores the unique ID from Google for users authenticating via Google OAuth. `sparse: true` allows users without a `googleId`.
-   **`authProvider`**: Indicates whether the user registered via 'email' or 'google'.

## Authentication Controllers (`backend/src/controllers/auth.controller.js`)

These controllers handle the core logic for user registration, login, logout, and profile management.

```javascript filename="backend/src/controllers/auth.controller.js"
import cloudinary from "../lib/cloudinary.js";
import { generateToken } from "../lib/utils.js";
import User from "../models/user.model.js";
import bcrypt from "bcryptjs";

export const signup = async (req, res) => {
    const {username, email, password} = req.body;
    try {
        // ... input validation ...

        const user = await User.findOne({email});
        if (user) return res.status(400).json({message: "Email already exists."});
        
        const existingUserByUsername = await User.findOne({ username });
        if (existingUserByUsername) {
            return res.status(400).json({ message: "Username already exists. Please choose another." });
        }

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        const newUser = new User({
            username,
            email,
            password: hashedPassword,
            authProvider: 'email'
        });
        if(newUser){
            generateToken(newUser._id, res); // Generate JWT and set as cookie
            await newUser.save();

            res.status(201).json({
                _id: newUser._id,
                username: newUser.username,
                email: newUser.email,   
                profilePic: newUser.profilePic,
                authProvider: newUser.authProvider
            });
        } else {
            res.status(400).json({message: "Invalid user data."});
        }
    } catch (error) { /* ... error handling ... */ }
};

export const login = async (req, res) => {
    const {email, password} = req.body;
    try {
        const user = await User.findOne({email});
        if(!user) {
            return res.status(400).json({message: "Invalid credentials."});
        }
        if(user.authProvider === 'google' && !user.password){
            return res.status(400).json({ message: "Please sign in with Google." });
        }

        const isPasswordCorrect = await bcrypt.compare(password, user.password);
        if(!isPasswordCorrect) {
            return res.status(400).json({message: "Invalid credentials."});
        }

        generateToken(user._id, res); // Generate JWT and set as cookie
        res.status(200).json({
            _id: user._id,
            username: user.username,
            email: user.email,
            profilePic: user.profilePic,
            authProvider: user.authProvider,
        });
    } catch (error) { /* ... error handling ... */ }
};

export const logout = (req, res) => {
    try {
        res.cookie("jwt", "", {maxAge: 0}); // Clear JWT cookie
        res.status(200).json({message: "Logged out successfully."})
    } catch(error) { /* ... error handling ... */ }
};

export const checkAuth = (req, res) => {
    try {
        // req.user is populated by protectRoute middleware
        res.status(200).json({
            _id: req.user._id,
            username: req.user.username,
            email: req.user.email,
            profilePic: req.user.profilePic,
            authProvider: req.user.authProvider,
            createdAt: req.user.createdAt
        });
    } catch (error) { /* ... error handling ... */ }
};

export const googleAuthCallback = async (req, res) => {
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
    try {
        if (!req.user) { // Passport failed to authenticate
            return res.redirect(`${frontendUrl}/login?error=google_auth_failed`);
        }
        generateToken(req.user._id, res); // Generate JWT for the Google-authenticated user
        res.redirect(frontendUrl); // Redirect to frontend
    } catch (error) { /* ... error handling ... */ }
};

export const checkUsernameAvailability = async (req, res) => {
    try {
        const { username } = req.params;
        // ... validation ...
        if (req.user.username === username) {
            return res.status(200).json({ available: true, message: "This is your current username." });
        }
        const existingUser = await User.findOne({ username: username });
        if (existingUser) {
            return res.status(200).json({ available: false, message: "Username is already taken." });
        }
        res.status(200).json({ available: true, message: "Username is available." });
    } catch (error) { /* ... error handling ... */ }
};

export const updateProfile = async (req, res) => {
    try {
        const { profilePic, username } = req.body;
        const userId = req.user._id;
        let userToUpdate = await User.findById(userId);

        // ... validation & check existing username ...

        const fieldsToUpdate = {};
        if (username && username.trim() !== userToUpdate.username) {
            fieldsToUpdate.username = username.trim();
        }
        if (profilePic) {
            const uploadResponse = await cloudinary.uploader.upload(profilePic);
            fieldsToUpdate.profilePic = uploadResponse.secure_url;
        }

        if (Object.keys(fieldsToUpdate).length === 0) {
            return res.status(400).json({ message: "No changes provided to update." });
        }

        const updatedUser = await User.findByIdAndUpdate(userId, { $set: fieldsToUpdate }, { new: true });
        generateToken(updatedUser._id, res); // Regenerate JWT with potentially new user info
        res.status(200).json(updatedUser);

    } catch (error) { /* ... error handling ... */ }
};
```
<details>
<summary>Source Code: `backend/src/controllers/auth.controller.js`</summary>

```javascript
import cloudinary from "../lib/cloudinary.js";
import { generateToken } from "../lib/utils.js";
import User from "../models/user.model.js";
import bcrypt from "bcryptjs";

export const signup = async (req, res) => {
    // console.log(req.body); //debugging
    const {username, email, password} = req.body;
    try {
        if(!username || !email || !password) {
            return res.status(400).json({message: "Please fill in all fields."});
        }
        if (username.length < 3) {
            return res.status(400).json({ message: "Username must be at least 3 characters." });
        }
        if (username.length > 20) {
            return res.status(400).json({ message: "Username cannot be more than 20 characters." });
        }
        if (password.length < 6) {
            return res.status(400).json({message: "Password must be at least 6 characters."});
        }
        const user = await User.findOne({email});
        if (user) return res.status(400).json({message: "Email already exists."});
        
        const existingUserByUsername = await User.findOne({ username });
        if (existingUserByUsername) {
            return res.status(400).json({ message: "Username already exists. Please choose another." });
        }

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        const newUser = new User({
            username,
            email,
            password: hashedPassword,
            authProvider: 'email'
        });
        if(newUser){
            //generate jwt token here
            generateToken(newUser._id, res);
            await newUser.save();

            res.status(201).json({
                _id: newUser._id,
                username: newUser.username,
                email: newUser.email,   
                profilePic: newUser.profilePic,
                authProvider: newUser.authProvider
            });
        } else {
            res.status(400).json({message: "Invalid user data."});
        }
    } catch (error) {
        console.log("Error in signup controller", error.message)
        res.status(500).json({message: "Something went wrong."});
    }
};

export const login = async (req, res) => {
    const {email, password} = req.body;
    try {
        const user = await User.findOne({email});

        if(!user) {
            return res.status(400).json({message: "Invalid credentials."});
        }

        if(user.authProvider === 'google' && !user.password){
            return res.status(400).json({ message: "Please sign in with Google." });
        }

        const isPasswordCorrect = await bcrypt.compare(password, user.password);
        if(!isPasswordCorrect) {
            return res.status(400).json({message: "Invalid credentials."});
        }

        generateToken(user._id, res);
        res.status(200).json({
            _id: user._id,
            username: user.username,
            email: user.email,
            profilePic: user.profilePic,
            authProvider: user.authProvider,
        });
    } catch (error) {
        console.log("Error in login controller", error.message);
        res.status(500).json({message: "Something went wrong."});
    }
};

export const logout = (req, res) => {
    try {
        res.cookie("jwt", "", {maxAge: 0});
        res.status(200).json({message: "Logged out successfully."})
    } catch(error) {
        console.log("Error in logout controller", error.message);
        res.status(500).json({message:"Internal Server Error"}); 
    }
};



export const checkAuth = (req, res) => {
    try {
        res.status(200).json({
            _id: req.user._id,
            username: req.user.username,
            email: req.user.email,
            profilePic: req.user.profilePic,
            authProvider: req.user.authProvider,
            createdAt: req.user.createdAt
        });
    } catch (error) {
        console.log("Error in checkAuth controller", error.message);
        res.status(500).json({message: "Internal Server Error"});
    }
};


export const googleAuthCallback = async (req, res) => {
 const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';

    try {
        if (!req.user) {
            return res.redirect(`${frontendUrl}/login?error=google_auth_failed`);
        }

        generateToken(req.user._id, res);

        res.redirect(frontendUrl);

    } catch (error) {
        console.error("Error in googleAuthCallback: ", error.message);
        res.redirect(`${frontendUrl}/login?error=google_auth_processing_error`);
    }
};

export const checkUsernameAvailability = async (req, res) => {
    try {
        const { username } = req.params;
        const currentUserId = req.user._id; 

        if (!username || username.trim().length < 3) {
            return res.status(400).json({ available: false, message: "Username must be at least 3 characters." });
        }
        if (username.trim().length > 20) {
            return res.status(400).json({ available: false, message: "Username cannot be more than 20 characters." });
        }
    
        // const usernameRegex = /^[a-zA-Z0-9_]+$/;
        // if (!usernameRegex.test(username)) {
        //     return res.status(400).json({ available: false, message: "Username contains invalid characters." });
        // }


        // Check if the username is the current user's existing username
        if (req.user.username === username) {
            return res.status(200).json({ available: true, message: "This is your current username." });
        }

        const existingUser = await User.findOne({ username: username });

        if (existingUser) {
            return res.status(200).json({ available: false, message: "Username is already taken." });
        }

        res.status(200).json({ available: true, message: "Username is available." });

    } catch (error) {
        console.error("Error in checkUsernameAvailability:", error.message);
        res.status(500).json({ available: false, message: "Error checking username availability." });
    }
};

// export const updateProfile = async (req, res) => {
//     try {
//         const {profilePic, username} = req.body;
//         const userId = req.user._id;
        
//         if(profilePic){
//             const uploadResponse = await cloudinary.uploader.upload(profilePic);
//         }
//         const userToUpdate = await User.findById(userId);
        
        
//         res.status(200).json(req.user);
//     }
//     catch (error) {
//         console.log("Error in updateProfile controller", error.message);
//         res.status(500).json({message: "Internal Server Error"});
//     }
// };


export const updateProfile = async (req, res) => {
    try {
        const { profilePic, username } = req.body; // Expect username now
        const userId = req.user._id;
        let userToUpdate = await User.findById(userId);

        if (!userToUpdate) {
            return res.status(404).json({ message: "User not found." });
        }

        const fieldsToUpdate = {};
        let newUsername = username ? username.trim() : null;
        let usernameChanged = false;

        // Handle username update
        if (newUsername && newUsername !== userToUpdate.username) {
            // Validate new username (length, characters - could reuse parts of checkUsernameAvailability logic or rely on schema)
            if (newUsername.length < 3 || newUsername.length > 20) {
                return res.status(400).json({ message: "Username must be between 3 and 20 characters." });
            }
            // const usernameRegex = /^[a-zA-Z0-9_]+$/; // Example regex
            // if (!usernameRegex.test(newUsername)) {
            //     return res.status(400).json({ message: "Username contains invalid characters." });
            // }

            const existingUserWithNewUsername = await User.findOne({ username: newUsername, _id: { $ne: userId } });
            if (existingUserWithNewUsername) {
                return res.status(400).json({ message: "This username is already taken by someone else." });
            }
            fieldsToUpdate.username = newUsername;
            usernameChanged = true;
        }

        // Handle profile picture update
        if (profilePic) {
            // Assuming profilePic is a base64 string or similar that Cloudinary handles
            const uploadResponse = await cloudinary.uploader.upload(profilePic);
            fieldsToUpdate.profilePic = uploadResponse.secure_url;
        }

        if (Object.keys(fieldsToUpdate).length === 0) {
            return res.status(400).json({ message: "No changes provided to update." });
        }

        const updatedUser = await User.findByIdAndUpdate(userId, { $set: fieldsToUpdate }, { new: true });

        if (!updatedUser) {
            // Should not happen if userToUpdate was found initially unless deleted concurrently
            return res.status(404).json({ message: "Failed to update user."});
        }

        // If username changed OR if you always want to refresh the token on profile update
        // It's good practice to issue a new token if sensitive/display info in it changes
        // For simplicity here, we'll assume generateToken will be called to refresh cookie with potentially new info
        generateToken(updatedUser._id, res); // This will set a new cookie with the same name, overriding the old one.

        res.status(200).json(updatedUser);

    } catch (error) {
        console.error("Error in updateProfile controller", error.message);
        if (error.code === 11000 && error.keyValue && error.keyValue.username) { // Duplicate key error from DB
            return res.status(400).json({ message: "This username is already taken." });
        }
        res.status(500).json({ message: "Internal Server Error while updating profile." });
    }
};
```
</details>

<br />

### Key Controller Functions

-   **`signup`**:
    -   Validates user input (username, email, password length).
    -   Checks for existing email and username.
    -   Hashes the password using `bcryptjs` for security.
    -   Creates a new `User` document with `authProvider: 'email'`.
    -   Generates a JWT using `generateToken` and sets it as an HttpOnly cookie.
    -   Responds with user data (excluding password).
-   **`login`**:
    -   Finds the user by email.
    -   Handles a special case for Google-authenticated users trying to log in with email/password (directs them to Google login).
    -   Compares the provided password with the stored hashed password using `bcrypt.compare`.
    -   Generates a JWT and sets it as an HttpOnly cookie upon successful login.
-   **`logout`**:
    -   Clears the HttpOnly JWT cookie by setting `maxAge: 0`.
-   **`checkAuth`**:
    -   This endpoint is protected by the `protectRoute` middleware (discussed below).
    -   It returns the authenticated user's details, which are populated on `req.user` by the middleware.
-   **`googleAuthCallback`**:
    -   This is the redirect endpoint after Google successfully authenticates a user via Passport.
    -   If `req.user` is present (meaning Passport successfully authenticated/registered a user), it generates a JWT and redirects the user to the frontend.
-   **`checkUsernameAvailability`**:
    -   Allows clients to check if a username is available before submission.
    -   It also handles the case where the checked username is the current user's own username.
-   **`updateProfile`**:
    -   Handles updating a user's `username` and `profilePic`.
    -   Performs validations similar to `signup` for username uniqueness (excluding the current user's own username).
    -   If `profilePic` is provided, it uploads the image to Cloudinary.
    -   Updates the user in the database.
    -   Regenerates the JWT and sets a new cookie to ensure the client has the most up-to-date user information (e.g., new username).

## Passport Configuration (`backend/src/lib/passport.config.js`)

Passport.js is used for Google OAuth authentication, abstracting the complex OAuth flow.

```javascript filename="backend/src/lib/passport.config.js"
import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import User from '../models/user.model.js'; 
import dotenv from 'dotenv';

dotenv.config(); 

export const configurePassport = () => {
    passport.use(new GoogleStrategy({
        clientID: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET,
        callbackURL: process.env.GOOGLE_CALLBACK_URL,
        scope: ['profile', 'email'] 
    },
    async (accessToken, refreshToken, profile, done) => {
        try {
            let user = await User.findOne({ googleId: profile.id });

            if (user) { // User already exists with Google ID
                return done(null, user);
            } else { // New Google user
                let username = profile.displayName.replace(/\s+/g, '').toLowerCase() || `user${Date.now()}`;
                // ... logic to ensure unique username ...

                const newUser = new User({
                    googleId: profile.id,
                    email: profile.emails && profile.emails[0] ? profile.emails[0].value : null,
                    username: username,
                    authProvider: 'google',
                });

                if (!newUser.email) {
                    return done(new Error("Email not provided by Google. Cannot create account."), null);
                }

                const existingUserByEmail = await User.findOne({ email: newUser.email });
                if (existingUserByEmail && existingUserByEmail.authProvider !== 'google') {
                    return done(null, false, { message: `An account with email ${newUser.email} already exists. Please sign in using your original method.` });
                }

                await newUser.save();
                return done(null, newUser);
            }
        } catch (error) {
            return done(error, null);
        }
    }));

    // Serialize user to store in session (just the user ID)
    passport.serializeUser((user, done) => {
        done(null, user.id); // user.id is the _id from MongoDB
    });

    // Deserialize user from session (fetch user from DB using the ID)
    passport.deserializeUser(async (id, done) => {
        try {
            const user = await User.findById(id);
            done(null, user); // This user object is attached to req.user
        } catch (error) {
            done(error, null);
        }
    });
};
```
<details>
<summary>Source Code: `backend/src/lib/passport.config.js`</summary>

```javascript
import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import User from '../models/user.model.js'; 
import dotenv from 'dotenv';

dotenv.config(); 

export const configurePassport = () => {
    passport.use(new GoogleStrategy({
        clientID: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET,
        callbackURL: process.env.GOOGLE_CALLBACK_URL,
        scope: ['profile', 'email'] 
    },
    async (accessToken, refreshToken, profile, done) => {
        try {
            // console.log("Google Profile:", profile); // 

            let user = await User.findOne({ googleId: profile.id });

            if (user) {
                return done(null, user);
            } else {
                let username = profile.displayName.replace(/\s+/g, '').toLowerCase() || `user${Date.now()}`;

                const existingUserByUsername = await User.findOne({ username });
                if (existingUserByUsername) {
                    username = `${username}${Date.now().toString().slice(-4)}`; // Make it more unique
                }
                if (username.length > 20) username = username.substring(0,20);


                const newUser = new User({
                    googleId: profile.id,
                    email: profile.emails && profile.emails[0] ? profile.emails[0].value : null, // Take the first email
                    username: username,
                    // profilePic: profile.photos && profile.photos[0] ? profile.photos[0].value : '', // Optional: Use Google profile pic
                    authProvider: 'google',
                });

                if (!newUser.email) {
                    return done(new Error("Email not provided by Google. Cannot create account."), null);
                }

                const existingUserByEmail = await User.findOne({ email: newUser.email });
                if (existingUserByEmail && existingUserByEmail.authProvider !== 'google') {
                    return done(null, false, { message: `An account with email ${newUser.email} already exists. Please sign in using your original method.` });
                }


                await newUser.save();
                return done(null, newUser);
            }
        } catch (error) {
            return done(error, null);
        }
    }));

    // Serialize user to store in session (just the user ID)
    passport.serializeUser((user, done) => {
        done(null, user.id); // user.id is the _id from MongoDB
    });

    // Deserialize user from session (fetch user from DB using the ID)
    passport.deserializeUser(async (id, done) => {
        try {
            const user = await User.findById(id);
            done(null, user); // This user object is attached to req.user
        } catch (error) {
            done(error, null);
        }
    });
};
```
</details>

<br />

-   **`GoogleStrategy`**: Configured with `clientID`, `clientSecret`, and `callbackURL` from environment variables. The `scope` requests `profile` and `email` information from Google.
-   **`verify` callback**: This asynchronous function is executed after Google authenticates the user.
    -   It checks if a user with the `googleId` already exists in the database.
    -   If not, it attempts to create a new user:
        -   Generates a unique username based on `displayName`.
        -   Checks for existing email (and prevents linking a Google login to an existing email-based account).
        -   Saves the new user to the database with `authProvider: 'google'`.
    -   Calls `done(error, user)` to pass the user (or error) back to Passport.
-   **`serializeUser`**: Stores only the user's MongoDB `_id` in the session, minimizing session data.
-   **`deserializeUser`**: Retrieves the full user object from the database using the stored `_id` and attaches it to `req.user` for subsequent requests within the same session. This is primarily for the Google OAuth flow which uses sessions, before a JWT is issued.

## Authentication Middleware (`backend/src/middleware/auth.middleware.js`)

The `protectRoute` middleware ensures that only authenticated users can access specific routes.

```javascript filename="backend/src/middleware/auth.middleware.js"
import jwt from "jsonwebtoken"
import User from "../models/user.model.js"

export const protectRoute = async (req, res, next) => {
    try {
        const token = req.cookies.jwt; // Extract JWT from HttpOnly cookie
        if(!token){
            return res.status(401).json({message: "Unauthorized - No Token Provided"});
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET) // Verify token

        if(!decoded) {
            return res.status(401).json({message: "Unauthorized - Invalid Token"});
        }
        const user = await User.findById(decoded.userId).select("-password"); // Find user without password

        if(!user) {
            return res.status(404).json({message: "User not found"});
        }
        req.user = user; // Attach user object to the request

        next(); // Proceed to the next middleware/route handler
    } catch (error) {
        console.log("Error in protectRoute middleware", error.message);
        res.status(500).json({message: "Internal Server Error"});
    }
};
```
<details>
<summary>Source Code: `backend/src/middleware/auth.middleware.js`</summary>

```javascript
import jwt from "jsonwebtoken"
import User from "../models/user.model.js"

export const protectRoute = async (req, res, next) => {
    try {
        const token = req.cookies.jwt;
        if(!token){
            return res.status(401).json({message: "Unauthorized - No Token Provided"});
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET)

        if(!decoded) {
            return res.status(401).json({message: "Unauthorized - Invalid Token"});
        }
        const user = await User.findById(decoded.userId).select("-password");

        if(!user) {
            return res.status(404).json({message: "User not found"});
        }
        req.user = user;

        next();
    } catch (error) {
        console.log("Error in protectRoute middleware", error.message);
        res.status(500).json({message: "Internal Server Error"});

    }

};
```
</details>

<br />

-   **JWT Extraction**: Retrieves the JWT from the `jwt` HttpOnly cookie.
-   **Token Verification**: Uses `jsonwebtoken.verify` to validate the token against `JWT_SECRET`.
-   **User Lookup**: Decodes the `userId` from the token and fetches the corresponding user from the database, excluding the password field.
-   **`req.user` Population**: If valid, the user object is attached to `req.user`, making it accessible in subsequent route handlers.

## Authentication Flow Diagrams

### Email/Password Authentication Flow

This diagram illustrates the typical user registration and login process using email and password.

````mermaid
graph TD
    A[Client] -- POST /api/auth/signup --> B(Server - auth.controller.js#signup)
    B -- Validate Input --> C{Email/Username Exists?}
    C -- Yes --> D[400 Bad Request]
    C -- No --> E(Hash Password - bcrypt)
    E -- Create New User --> F(Save User to DB)
    F -- Generate JWT --> G(Set JWT as HttpOnly Cookie)
    G -- 201 Created & User Data --> A
    A -- POST /api/auth/login --> H(Server - auth.controller.js#login)
    H -- Find User by Email --> I{Password Correct?}
    I -- No --> J[400 Bad Request]
    I -- Yes --> K(Generate JWT)
    K -- Set JWT as HttpOnly Cookie --> L(200 OK & User Data)
    L --> A
```

### JWT Authorization Flow

This diagram shows how JWTs are used to authorize requests to protected routes after a user has logged in.

````mermaid
graph TD
    A[Client] -- Request to Protected Route (e.g., /api/users/profile) with JWT Cookie --> B(Server - auth.middleware.js#protectRoute)
    B -- Extract JWT from Cookie --> C{Token Exists?}
    C -- No --> D[401 Unauthorized]
    C -- Yes --> E{Verify JWT & Decode}
    E -- Invalid --> D
    E -- Valid (payload includes userId) --> F(Find User by userId in DB)
    F -- User Not Found --> G[404 Not Found]
    F -- User Found --> H(Attach User to req.user)
    H -- next() --> I(Route Handler - e.g., auth.controller.js#checkAuth)
    I -- Access req.user --> J(Perform Action & Respond)
    J --> K[200 OK & Data]
    K --> A
```

### Google OAuth Authentication Flow

This diagram outlines the process of authenticating users via Google, leveraging Passport.js.

````mermaid
graph TD
    A[Client] -- Click "Sign in with Google" --> B(Server - /api/auth/google)
    B -- Redirect to Google Auth Page --> C[Google]
    C -- User Authenticates & Authorizes --> D(Google)
    D -- Redirect to /api/auth/google/callback with code --> E(Server - passport.config.js & auth.controller.js#googleAuthCallback)
    E -- Passport Strategy: Verify User/Create New User --> F{User Exists in DB?}
    F -- Yes --> G(Load User)
    F -- No --> H(Create User with Google ID)
    G --& H -- done(null, user) --> I(Passport.serializeUser)
    I -- Store User ID in Session --> J(Redirect to Frontend)
    J -- Generate JWT (in googleAuthCallback) --> K(Set JWT as HttpOnly Cookie)
    K -- Redirect to / (or original target) --> L[Client - Authenticated]
```

## Relevant Files

-   **Backend:**
    -   [`backend/src/middleware/auth.middleware.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/middleware/auth.middleware.js)
    -   [`backend/src/lib/passport.config.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/lib/passport.config.js)
    -   [`backend/src/routes/auth.route.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/routes/auth.route.js) (Defines routes for these controllers)
    -   [`backend/src/controllers/auth.controller.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js)
    -   [`backend/src/models/user.model.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/models/user.model.js)
-   **Frontend:**
    -   [`frontend/src/pages/LoginPage.jsx`](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/pages/LoginPage.jsx) (Login forms and Google login initiation)
    -   [`frontend/src/pages/SignUpPage.jsx`](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/pages/SignUpPage.jsx) (User registration forms)
    -   [`frontend/src/store/useAuthStore.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/store/useAuthStore.js) (Manages authentication state in the frontend)
    -   [`frontend/src/lib/axios.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/lib/axios.js) (Configured to send cookies with requests, allowing JWT to be sent automatically)

Next: [Real-time Communication (Chat)](./5_realtime_communication_chat.mdx)