---
title: "Database and Authentication"
description: "Details on database connection, user authentication, and authorization mechanisms."
sidebar_position: 22
---
 # Database and Authentication

This section provides an in-depth look into how the application manages its database connections, handles user authentication, and implements authorization mechanisms. It covers the core components responsible for user registration, login, logout, profile management, and ensuring secure access to protected routes, including integration with external authentication providers like Google.

## Database Connection

The application uses Mongoose to interact with its MongoDB database. The `connectDB` function in `backend/src/lib/db.js` is responsible for establishing this connection, ensuring that the application can persist and retrieve data efficiently.

The connection logic is straightforward, leveraging environment variables for the MongoDB URI to maintain flexibility across different deployment environments.

```javascript
// backend/src/lib/db.js
import mongoose from "mongoose"

export const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI);
    console.log(`MongoDB connected:  ${conn.connection.host}`);
  }
  catch(error){
    console.log("MongoDB connection error: ", error);
  }
}
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/lib/db.js)

This snippet demonstrates the asynchronous connection to MongoDB, logging a success message or an error if the connection fails.

## User Authentication

Authentication is handled primarily through `backend/src/controllers/auth.controller.js` for traditional email/password flows and `backend/src/lib/passport.config.js` for Google OAuth integration. JWTs (JSON Web Tokens) are used for session management.

### Email/Password Authentication Flow

The `signup` and `login` controllers manage the lifecycle of a user authenticated via email and password.

#### User Registration (Signup)

The `signup` controller handles new user registrations. It performs input validation, checks for existing users by email and username, hashes passwords using `bcryptjs`, saves the new user to the database, and issues a JWT for immediate authentication.

```javascript
// backend/src/controllers/auth.controller.js - Signup excerpt
export const signup = async (req, res) => {
    const {username, email, password} = req.body;
    try {
        if(!username || !email || !password) {
            return res.status(400).json({message: "Please fill in all fields."});
        }
        // ... (validation checks for username and password length)
        const user = await User.findOne({email});
        if (user) return res.status(400).json({message: "Email already exists."});
        
        const existingUserByUsername = await User.findOne({ username });
        if (existingUserByUsername) {
            return res.status(400).json({ message: "Username already exists. Please choose another." });
        }

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        const newUser = new User({
            username,
            email,
            password: hashedPassword,
            authProvider: 'email'
        });
        if(newUser){
            generateToken(newUser._id, res); // Issues JWT
            await newUser.save();
            res.status(201).json({ /* user data */ });
        } else {
            res.status(400).json({message: "Invalid user data."});
        }
    } catch (error) { /* error handling */ }
};
```
[View `signup` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L7-L58)

#### User Login

The `login` controller authenticates existing users. It verifies the provided email and password against stored credentials and issues a new JWT upon successful authentication. It also handles edge cases for users who originally signed up via Google.

```javascript
// backend/src/controllers/auth.controller.js - Login excerpt
export const login = async (req, res) => {
    const {email, password} = req.body;
    try {
        const user = await User.findOne({email});
        if(!user) {
            return res.status(400).json({message: "Invalid credentials."});
        }
        if(user.authProvider === 'google' && !user.password){
            return res.status(400).json({ message: "Please sign in with Google." });
        }
        const isPasswordCorrect = await bcrypt.compare(password, user.password);
        if(!isPasswordCorrect) {
            return res.status(400).json({message: "Invalid credentials."});
        }
        generateToken(user._id, res); // Issues JWT
        res.status(200).json({ /* user data */ });
    } catch (error) { /* error handling */ }
};
```
[View `login` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L60-L90)

#### User Logout

The `logout` function simply clears the `jwt` cookie, effectively logging the user out by invalidating their session.

```javascript
// backend/src/controllers/auth.controller.js - Logout excerpt
export const logout = (req, res) => {
    try {
        res.cookie("jwt", "", {maxAge: 0});
        res.status(200).json({message: "Logged out successfully."})
    } catch(error) { /* error handling */ }
};
```
[View `logout` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L93-L100)

### Google OAuth 2.0 Integration

Google authentication is implemented using Passport.js with the `passport-google-oauth20` strategy. This allows users to register and log in using their Google accounts.

#### Passport Configuration

The `configurePassport` function sets up the Google strategy. It finds or creates a user based on their Google ID, handles username uniqueness, and ensures an email is provided. It also defines how users are serialized (stored) and deserialized (retrieved) from the session.

```javascript
// backend/src/lib/passport.config.js - GoogleStrategy excerpt
passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: process.env.GOOGLE_CALLBACK_URL,
    scope: ['profile', 'email'] 
},
async (accessToken, refreshToken, profile, done) => {
    try {
        let user = await User.findOne({ googleId: profile.id });
        if (user) {
            return done(null, user);
        } else {
            // Logic to create new user, handle username uniqueness, and check for existing email
            // ...
            const newUser = new User({
                googleId: profile.id,
                email: profile.emails && profile.emails[0] ? profile.emails[0].value : null,
                username: username,
                authProvider: 'google',
            });
            await newUser.save();
            return done(null, newUser);
        }
    } catch (error) {
        return done(error, null);
    }
}));
```
[View `configurePassport` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/lib/passport.config.js#L14-L67)

This snippet illustrates the core logic for processing Google profile data: checking if the user already exists, and if not, creating a new user entry with their Google details.

#### Google Authentication Callback

The `googleAuthCallback` controller is the endpoint where Google redirects after successful authentication. It issues a JWT for the authenticated user and redirects them to the frontend.

```javascript
// backend/src/controllers/auth.controller.js - googleAuthCallback excerpt
export const googleAuthCallback = async (req, res) => {
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
    try {
        if (!req.user) {
            return res.redirect(`${frontendUrl}/login?error=google_auth_failed`);
        }
        generateToken(req.user._id, res); // Issues JWT
        res.redirect(frontendUrl);
    } catch (error) { /* error handling */ }
};
```
[View `googleAuthCallback` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L123-L139)

### Authentication Flow (Signup Example)

The following sequence diagram illustrates the user signup process:





```mermaid
sequenceDiagram
    participant C as "Client"
    participant A as "Authentication API"
    participant D as "Database (MongoDB)"
    C->>+A: "POST /api/auth/signup with {username, email, password}"
    A->>A: "Validate Input"
    alt Input is invalid
        A->>-C: "400 Bad Request: Invalid fields"
    else Input is valid
        A->>+D: "Query User.findOne({email})"
        D->>-A: "User (if exists) / null"
        alt Email already exists
            A->>-C: "400 Bad Request: Email exists"
        else Email is unique
            A->>+D: "Query User.findOne({username})"
            D->>-A: "User (if exists) / null"
            alt Username already exists
                A->>-C: "400 Bad Request: Username exists"
            else Username is unique
                A->>A: "Hash Password (bcryptjs)"
                A->>+D: "Create and Save New User"
                D->>-A: "New User Document"
                A->>A: "Generate JWT Token"
                A->>-C: "201 Created: User data + JWT cookie"
            end
        end
    end
```



## Authorization

Authorization ensures that authenticated users have the necessary permissions to access specific resources or perform certain actions. This is primarily handled by the `protectRoute` middleware.

### `protectRoute` Middleware

The `protectRoute` middleware, defined in `backend/src/middleware/auth.middleware.js`, acts as a gatekeeper for routes that require authentication. It extracts the JWT from the request cookie, verifies its authenticity, and then fetches the corresponding user from the database, attaching it to `req.user`.

```javascript
// backend/src/middleware/auth.middleware.js - protectRoute excerpt
import jwt from "jsonwebtoken"
import User from "../models/user.model.js"

export const protectRoute = async (req, res, next) => {
    try {
        const token = req.cookies.jwt;
        if(!token){
            return res.status(401).json({message: "Unauthorized - No Token Provided"});
        }
        const decoded = jwt.verify(token, process.env.JWT_SECRET)
        if(!decoded) {
            return res.status(401).json({message: "Unauthorized - Invalid Token"});
        }
        const user = await User.findById(decoded.userId).select("-password");
        if(!user) {
            return res.status(404).json({message: "User not found"});
        }
        req.user = user; // Attach user to request
        next(); // Proceed to the next middleware or route handler
    } catch (error) { /* error handling */ }
};
```
[View `protectRoute` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/middleware/auth.middleware.js)

This middleware is crucial for securing endpoints, ensuring that only authenticated users with valid tokens can access protected resources.

## User Profile Management

The `updateProfile` and `checkUsernameAvailability` controllers allow users to manage their profiles after authentication.

### Checking Username Availability

The `checkUsernameAvailability` controller, accessible via `req.user`, allows a user to check if a desired username is available. It prevents users from selecting usernames that are already taken by other users, or are too short/long. It also allows a user to keep their current username without being flagged as unavailable.

```javascript
// backend/src/controllers/auth.controller.js - checkUsernameAvailability excerpt
export const checkUsernameAvailability = async (req, res) => {
    try {
        const { username } = req.params;
        const currentUserId = req.user._id; 
        if (!username || username.trim().length < 3) {
            return res.status(400).json({ available: false, message: "Username must be at least 3 characters." });
        }
        // ... (other length validations)

        // Check if the username is the current user's existing username
        if (req.user.username === username) {
            return res.status(200).json({ available: true, message: "This is your current username." });
        }
        const existingUser = await User.findOne({ username: username });
        if (existingUser) {
            return res.status(200).json({ available: false, message: "Username is already taken." });
        }
        res.status(200).json({ available: true, message: "Username is available." });
    } catch (error) { /* error handling */ }
};
```
[View `checkUsernameAvailability` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L141-L181)

### Updating User Profile

The `updateProfile` controller enables authenticated users to update their profile picture and username. It integrates with Cloudinary for image uploads and includes validation for username changes, preventing duplicates.

```javascript
// backend/src/controllers/auth.controller.js - updateProfile excerpt
export const updateProfile = async (req, res) => {
    try {
        const { profilePic, username } = req.body;
        const userId = req.user._id;
        let userToUpdate = await User.findById(userId);

        // ... (validation for username, check for existing usernames)
        const fieldsToUpdate = {};
        if (username && username !== userToUpdate.username) {
            fieldsToUpdate.username = username;
        }
        if (profilePic) {
            const uploadResponse = await cloudinary.uploader.upload(profilePic);
            fieldsToUpdate.profilePic = uploadResponse.secure_url;
        }
        if (Object.keys(fieldsToUpdate).length === 0) {
            return res.status(400).json({ message: "No changes provided to update." });
        }
        const updatedUser = await User.findByIdAndUpdate(userId, { $set: fieldsToUpdate }, { new: true });
        generateToken(updatedUser._id, res); // Refresh JWT token
        res.status(200).json(updatedUser);
    } catch (error) { /* error handling */ }
};
```
[View `updateProfile` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L190-L248)

This controller ensures that profile updates are processed securely, including re-issuing a JWT to reflect any changes in user data, such as the username, which might be included in the token payload.

## Key Integration Points

*   **JWT Generation and Verification**: `generateToken` (from `backend/src/lib/utils.js`, not provided but implied) is used across `signup`, `login`, `googleAuthCallback`, and `updateProfile` to issue JWTs. These tokens are then verified by `protectRoute` middleware to secure endpoints.
*   **Database Interaction**: The `User` model (`backend/src/models/user.model.js`, not provided but implied) is central to all authentication and authorization logic, interacting with MongoDB for user storage and retrieval.
*   **Environment Variables**: Sensitive information like `MONGODB_URI`, `JWT_SECRET`, `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET`, and `GOOGLE_CALLBACK_URL` are managed through environment variables (`.env`) for security and configuration flexibility.
*   **Error Handling**: Consistent error handling is implemented across controllers and middleware to provide meaningful feedback to clients and log server-side issues.

The robust authentication and authorization framework is essential for maintaining the security and integrity of user data within the application.