---
title: "Authentication and Authorization"
description: "Details on user authentication, session management, and authorization middleware in the backend."
sidebar_position: 21
---
 # Authentication and Authorization

This section delves into how users are authenticated and authorized within the backend system. It covers the mechanisms for user registration, login, logout, session management using JSON Web Tokens (JWTs), and integrating third-party authentication via Google OAuth. The `protectRoute` middleware is also detailed, ensuring that only authenticated users can access specific routes.

The core of the authentication system revolves around secure password handling, JWT-based session management, and a flexible architecture that supports both traditional email/password and social logins.

## Core Concepts

### Local Authentication (Email/Password)

The system provides standard signup and login functionalities using email and password. Passwords are securely hashed using `bcryptjs` before storage, ensuring that plaintext passwords are never stored in the database.

Upon successful login or signup, a JWT is generated and set as an HTTP-only cookie, providing a secure, stateless session mechanism.

**Relevant Files:**
*   [`backend/src/controllers/auth.controller.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js)
*   [`backend/src/routes/auth.route.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/routes/auth.route.js)

#### Signup Process

The `signup` controller handles new user registrations. It performs validations for username, email, and password, checks for existing users, hashes the password, and creates a new user record. A JWT is then generated for the new user and sent in a cookie.

```javascript filename="backend/src/controllers/auth.controller.js"
export const signup = async (req, res) => {
    const {username, email, password} = req.body;
    try {
        // ... input validation and existing user checks ...

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        const newUser = new User({
            username,
            email,
            password: hashedPassword,
            authProvider: 'email'
        });
        if(newUser){
            generateToken(newUser._id, res); // Generate JWT and set cookie
            await newUser.save();

            res.status(201).json({
                _id: newUser._id,
                username: newUser.username,
                email: newUser.email,   
                profilePic: newUser.profilePic,
                authProvider: newUser.authProvider
            });
        } else {
            res.status(400).json({message: "Invalid user data."});
        }
    } catch (error) {
        console.log("Error in signup controller", error.message)
        res.status(500).json({message: "Something went wrong."});
    }
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L7-L58)

#### Login Process

The `login` controller verifies user credentials against stored hashed passwords. It also includes logic to prevent email/password login for users originally registered via Google OAuth. On successful authentication, a new JWT is issued.

```javascript filename="backend/src/controllers/auth.controller.js"
export const login = async (req, res) => {
    const {email, password} = req.body;
    try {
        const user = await User.findOne({email});

        if(!user) {
            return res.status(400).json({message: "Invalid credentials."});
        }

        if(user.authProvider === 'google' && !user.password){
            return res.status(400).json({ message: "Please sign in with Google." });
        }

        const isPasswordCorrect = await bcrypt.compare(password, user.password);
        if(!isPasswordCorrect) {
            return res.status(400).json({message: "Invalid credentials."});
        }

        generateToken(user._id, res); // Generate JWT and set cookie
        res.status(200).json({
            _id: user._id,
            username: user.username,
            email: user.email,
            profilePic: user.profilePic,
            authProvider: user.authProvider,
        });
    } catch (error) {
        console.log("Error in login controller", error.message);
        res.status(500).json({message: "Something went wrong."});
    }
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L60-L95)

#### Logout

The `logout` function simply clears the JWT cookie, effectively ending the user's session.

```javascript filename="backend/src/controllers/auth.controller.js"
export const logout = (req, res) => {
    try {
        res.cookie("jwt", "", {maxAge: 0});
        res.status(200).json({message: "Logged out successfully."})
    } catch(error) {
        console.log("Error in logout controller", error.message);
        res.status(500).json({message:"Internal Server Error"}); 
    }
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L98-L105)

### Google OAuth Integration

The application supports signing in with Google using Passport.js. This provides a convenient and secure way for users to authenticate without creating a new password.

**Relevant Files:**
*   [`backend/src/lib/passport.config.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/lib/passport.config.js)
*   [`backend/src/routes/auth.route.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/routes/auth.route.js)
*   [`backend/src/controllers/auth.controller.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js)

#### Passport.js Configuration

`passport.config.js` sets up the Google OAuth 2.0 strategy. It handles the callback from Google, either finding an existing user or creating a new one based on their Google profile. It also includes logic to handle potential username conflicts and existing email accounts.

```javascript filename="backend/src/lib/passport.config.js"
export const configurePassport = () => {
    passport.use(new GoogleStrategy({
        clientID: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET,
        callbackURL: process.env.GOOGLE_CALLBACK_URL,
        scope: ['profile', 'email'] 
    },
    async (accessToken, refreshToken, profile, done) => {
        try {
            let user = await User.findOne({ googleId: profile.id });

            if (user) {
                return done(null, user);
            } else {
                // ... logic for creating new user, handling username conflicts and existing email accounts ...
                const newUser = new User({
                    googleId: profile.id,
                    email: profile.emails && profile.emails[0] ? profile.emails[0].value : null,
                    username: username,
                    authProvider: 'google',
                });
                await newUser.save();
                return done(null, newUser);
            }
        } catch (error) {
            return done(error, null);
        }
    }));
    // ... serializeUser and deserializeUser ...
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/lib/passport.config.js#L9-L65)

#### Google Authentication Flow





```mermaid
graph TD
    A["Frontend"] -->|Click "Sign in with Google"| B["GET /api/auth/google"]
    B -->|Initiate OAuth| C["Passport.js"]
    C -->|Redirect to Google for authentication| D["Google Accounts"]
    D -->|User authenticates and grants permission| E["Google OAuth Callback"]
    E -->|Redirect to /api/auth/google/callback| F["Passport.js (GoogleStrategy)"]
    F -->|Verify token, find/create user| G["Auth Controller: googleAuthCallback"]
    G -->|generateToken(user._id, res)| H["Set 'jwt' cookie"]
    H -->|Redirect to Frontend (Homepage)| A
```



### Authorization Middleware (`protectRoute`)

The `protectRoute` middleware is crucial for enforcing authorization. It ensures that only authenticated users can access protected routes. It works by verifying the JWT found in the request cookies.

**Relevant Files:**
*   [`backend/src/middleware/auth.middleware.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/middleware/auth.middleware.js)
*   [`backend/src/routes/auth.route.js`](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/routes/auth.route.js)

#### `protectRoute` Logic

The middleware extracts the JWT from `req.cookies.jwt`, verifies its authenticity and expiration, decodes the user ID, and fetches the corresponding user from the database. If successful, the user object is attached to `req.user`, allowing subsequent route handlers to access authenticated user information.

```javascript filename="backend/src/middleware/auth.middleware.js"
export const protectRoute = async (req, res, next) => {
    try {
        const token = req.cookies.jwt;
        if(!token){
            return res.status(401).json({message: "Unauthorized - No Token Provided"});
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET)

        if(!decoded) {
            return res.status(401).json({message: "Unauthorized - Invalid Token"});
        }
        const user = await User.findById(decoded.userId).select("-password");

        if(!user) {
            return res.status(404).json({message: "User not found"});
        }
        req.user = user; // Attach user to request object

        next(); // Proceed to the next middleware or route handler
    } catch (error) {
        console.log("Error in protectRoute middleware", error.message);
        res.status(500).json({message: "Internal Server Error"});
    }
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/middleware/auth.middleware.js#L5-L27)

#### Authorization Flow





```mermaid
graph TD
    A["Client Request"] -->|Contains 'jwt' Cookie| B["Protected Route (e.g., /api/auth/check)"]
    B -->|Calls protectRoute middleware| C["protectRoute Middleware"]
    C -->|Check for JWT in cookie| D{"Is JWT present?"}
    D -->|No| E["401 Unauthorized - No Token"]
    D -->|Yes| F{"Verify JWT (jwt.verify)"}
    F -->|Invalid/Expired| G["401 Unauthorized - Invalid Token"]
    F -->|Valid| H["Decode userId from JWT"]
    H -->|Fetch user from DB| I{"Is User found?"}
    I -->|No| J["404 User Not Found"]
    I -->|Yes| K["Attach User to req.user"]
    K -->|Call next()| L["Route Handler (e.g., checkAuth)"]
    L -->|Respond with user data| M["Client Response"]
```



### User Profile Management

The system allows authenticated users to update their profile, specifically their username and profile picture. This is handled by a protected route, ensuring only the authenticated user can modify their own profile.

#### Update Profile

The `updateProfile` controller handles changes to a user's `username` and `profilePic`. It includes validation for the new username and utilizes Cloudinary for secure storage of profile pictures. After a successful update, a new JWT is issued to reflect any updated user information.

```javascript filename="backend/src/controllers/auth.controller.js"
export const updateProfile = async (req, res) => {
    try {
        const { profilePic, username } = req.body;
        const userId = req.user._id;
        let userToUpdate = await User.findById(userId);

        // ... validation and checks for username uniqueness ...

        const fieldsToUpdate = {};
        if (username && username.trim() !== userToUpdate.username) {
            fieldsToUpdate.username = username.trim();
        }
        if (profilePic) {
            const uploadResponse = await cloudinary.uploader.upload(profilePic);
            fieldsToUpdate.profilePic = uploadResponse.secure_url;
        }

        if (Object.keys(fieldsToUpdate).length === 0) {
            return res.status(400).json({ message: "No changes provided to update." });
        }

        const updatedUser = await User.findByIdAndUpdate(userId, { $set: fieldsToUpdate }, { new: true });
        generateToken(updatedUser._id, res); // Refresh JWT with updated info

        res.status(200).json(updatedUser);

    } catch (error) {
        console.error("Error in updateProfile controller", error.message);
        res.status(500).json({ message: "Internal Server Error while updating profile." });
    }
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L198-L264)

#### Username Availability Check

Before allowing a user to change their username, an endpoint `/api/auth/username/check/:username` is available. This route, also protected, allows the client to verify if a desired username is available, preventing conflicts.

```javascript filename="backend/src/controllers/auth.controller.js"
export const checkUsernameAvailability = async (req, res) => {
    try {
        const { username } = req.params;
        const currentUserId = req.user._id; 

        // ... username validation ...

        if (req.user.username === username) {
            return res.status(200).json({ available: true, message: "This is your current username." });
        }

        const existingUser = await User.findOne({ username: username });

        if (existingUser) {
            return res.status(200).json({ available: false, message: "Username is already taken." });
        }

        res.status(200).json({ available: true, message: "Username is available." });

    } catch (error) {
        console.error("Error in checkUsernameAvailability:", error.message);
        res.status(500).json({ available: false, message: "Error checking username availability." });
    }
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L156-L194)

## Key Integration Points

### Route Definitions

All authentication and authorization related routes are defined in `backend/src/routes/auth.route.js`. This file aggregates all the controller functions and applies middleware where necessary.

```javascript filename="backend/src/routes/auth.route.js"
import express from "express"
import passport from 'passport';
import { login, logout, signup, updateProfile, checkAuth, googleAuthCallback, checkUsernameAvailability} from  "../controllers/auth.controller.js"
import { protectRoute } from "../middleware/auth.middleware.js"
const router = express.Router();

router.post("/signup", signup);
router.post("/login", login);
router.post("/logout", logout);
router.put("/update-profile", protectRoute ,updateProfile)
router.get("/username/check/:username", protectRoute, checkUsernameAvailability);
router.get("/check", protectRoute, checkAuth) // Check if user is authenticated

router.get(
    '/google',
    passport.authenticate('google', { scope: ['profile', 'email'] })
);
router.get(
    '/google/callback',
    passport.authenticate('google', {
        failureRedirect: 'http://localhost:5173/login', 
        failureMessage: true 
    }),
    googleAuthCallback 
);
export default router;
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/routes/auth.route.js#L4-L31)

### Best Practices

*   **HTTP-Only Cookies:** JWTs are stored in HTTP-only cookies to mitigate XSS attacks.
*   **Password Hashing:** `bcryptjs` is used for robust password hashing.
*   **Input Validation:** Comprehensive server-side validation is implemented for all user inputs (username, email, password) to prevent common vulnerabilities.
*   **Stateless Authentication:** JWTs enable a stateless backend, which simplifies scaling.
*   **Secure Google OAuth:** Uses Passport.js for a standardized and secure OAuth 2.0 implementation, handling user profile retrieval and account linking/creation.
*   **Middleware for Protection:** The `protectRoute` middleware centralizes authorization logic, ensuring that protected routes can only be accessed by authenticated users.

Next: [Messaging and Friend Management](./2.2_messaging-and-friend-management.mdx)