---
title: "Interactive 3D Scenes"
description: "Details on the 3D interactive elements of the portfolio."
sidebar_position: 22
---

# Interactive 3D Scenes

This section details the interactive 3D elements within the portfolio, showcasing proficiency in creating engaging and visually appealing user experiences with Three.js. The portfolio leverages React Three Fiber to simplify the integration of Three.js scenes into a React application.

## Features

*   **Dynamic Particle Systems:** Utilizes points and point clouds to create visually rich and interactive backgrounds.
*   **Interactive Objects:** Implements mouse tracking to influence object rotation, scaling, and color.
*   **Post-Processing Effects:** Employs bloom and chromatic aberration effects to enhance visual appeal.
*   **Custom Shapes:** Introduces custom 3D shapes beyond basic primitives to represent coding concepts.
*   **Optimized Performance:** Balances visual quality with performance considerations, especially on different devices.

## Core Components

*   `IcoSphereScene.jsx`: Generates a dynamic scene of colorful, interactive icospheres.
*   `InteractiveBackgroundScene.jsx`: Creates an interactive background featuring icospheres that respond to mouse movement.
*   `Scene3D.jsx`: A general-purpose 3D scene with particle fields and floating geometry.

## Code Snippets and Explanations

1.  **Creating a Circle Texture:** This snippet demonstrates how to create a simple radial gradient texture for use with point clouds.

    ```javascript
    // src/components/InteractiveBackgroundScene.jsx
    function createCircleTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;

      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.5, 'rgba(255,255,255,0.5)');
      gradient.addColorStop(1, 'rgba(255,255,255,0)');

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 64, 64);

      const texture = new THREE.CanvasTexture(canvas);
      texture.generateMipmaps = false;
      texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;

      return texture;
    }
    ```

    This function creates a canvas element, draws a radial gradient on it, and then uses the canvas content to create a Three.js texture. The texture is then used as a `map` for the `PointsMaterial`, giving the particles a soft, round appearance.

    [View on GitHub](https://github.com/santrupt29/portfolio/blob/main/src/components/InteractiveBackgroundScene.jsx)

2.  **Interactive Icosphere (Mesh):**

    ```javascript
    // src/components/InteractiveBackgroundScene.jsx
    function InteractiveIcoSphere({ index, position }) {
      const meshRef = useRef();
      const materialRef = useRef();
      const { mouse, viewport } = useThree();
      // ... (rest of the component)

      useFrame((state, deltaTime) => {
        // ... (cursor tracking, scaling, color changes)
      });

      return (
        <mesh ref={meshRef} position={position}>
          <icosahedronGeometry args={[radius, detail]} />
          <meshStandardMaterial
            ref={materialRef}
            color={baseColor}
            emissive={new THREE.Color(0x000000)}
            roughness={0.4}
            metalness={0.6}
            transparent={false} // Make them opaque
          />
        </mesh>
      );
    }
    ```

    This component creates an individual interactive icosphere using a `mesh` and `meshStandardMaterial`, reacting to the cursor. It dynamically adjusts rotation, scale, and color based on mouse position.

    [View on GitHub](https://github.com/santrupt29/portfolio/blob/main/src/components/InteractiveBackgroundScene.jsx)

3.  **Creative Shape Handling:** Demonstrates how to generate different shapes beyond icospheres.

    ```javascript
    // src/components/IcoSphereScene.jsx
    function CreativeShape({ index, position, shapeType = 'icosphere' }) {
      // ...

      const { geometry, colors, sprite } = useMemo(() => {
        let geo;

        switch (shapeType) {
          case 'code_bracket':
            // Create a bracket-like shape using extrude geometry
            const bracketShape = new THREE.Shape();
            bracketShape.moveTo(0, -1);
            bracketShape.lineTo(-0.3, -1);
            bracketShape.lineTo(-0.3, -0.8);
            bracketShape.lineTo(-0.1, -0.8);
            bracketShape.lineTo(-0.1, 0.8);
            bracketShape.lineTo(-0.3, 0.8);
            bracketShape.lineTo(-0.3, 1);
            bracketShape.lineTo(0, 1);
            geo = new THREE.ExtrudeGeometry(bracketShape, { depth: 0.2, bevelEnabled: false });
            break;

          // ... other shapes

          default:
            // Original icosphere (keeping it beautiful)
            geo = new THREE.IcosahedronGeometry(2, 4);
        }

        // ... color generation

        return {
          geometry: geo,
          colors: new Float32Array(colors),
          sprite: createCircleTexture()
        };
      }, [index, shapeType]);

      // ...
    }
    ```

    This code snippet illustrates the use of `ExtrudeGeometry` to create a custom shape representing a code bracket. It highlights the flexibility of Three.js in creating varied and meaningful 3D objects.

    [View on GitHub](https://github.com/santrupt29/portfolio/blob/main/src/components/IcoSphereScene.jsx)

4.  **Particle System Animation:** Animates the particles in `Scene3D.jsx`.

    ```javascript
    // src/components/Scene3D.jsx
    function ParticleField({ count = 5000 }) {
      const points = useRef()
      const particlesPosition = useMemo(() => random.inSphere(new Float32Array(count * 3), { radius: 50 }), [count])

      useFrame((state) => {
        if (points.current) {
          points.current.rotation.x = state.clock.elapsedTime * 0.05
          points.current.rotation.y = state.clock.elapsedTime * 0.075
        }
      })

      return (
        <group rotation={[0, 0, Math.PI / 4]}>
          <Points ref={points} positions={particlesPosition} stride={3} frustumCulled={false}>
            <PointMaterial
              transparent
              color="#f59e0b"
              size={0.15}
              sizeAttenuation={true}
              depthWrite={false}
            />
          </Points>
        </group>
      )
    }
    ```

    This component sets up a particle system using `Points` and `PointMaterial`. The `useFrame` hook is used to rotate the particle field, creating a dynamic and visually interesting effect.

    [View on GitHub](https://github.com/santrupt29/portfolio/blob/main/src/components/Scene3D.jsx)

5.  **Post-Processing with Bloom:** Applies a bloom effect to enhance the visual quality.

    ```javascript
    // src/components/IcoSphereScene.jsx
    <EffectComposer>
      <Bloom
        luminanceThreshold={0.1}
        luminanceSmoothing={0.9}
        height={300}
        opacity={0.8}
      />
      <ChromaticAberration offset={[0.002, 0.002]} />
    </EffectComposer>
    ```

    The `Bloom` effect is used to create a soft glow around bright areas in the scene, enhancing the overall visual appeal. `ChromaticAberration` adds a subtle distortion effect.

    [View on GitHub](https://github.com/santrupt29/portfolio/blob/main/src/components/IcoSphereScene.jsx)

6.  **Dynamic Lighting:** Controls lighting based on cursor position.

    ```javascript
    // src/components/InteractiveBackgroundScene.jsx
    function InteractiveLighting() {
      const lightRef = useRef();
      const { mouse } = useThree();

      useFrame(() => {
        if (lightRef.current) {
          lightRef.current.position.x = mouse.x * 10;
          lightRef.current.position.y = mouse.y * 8 + 5;

          const hue = (mouse.x + 1) * 0.5;
          lightRef.current.color.setHSL(hue, 0.8, 0.8);
        }
      });

      return (
        <pointLight
          ref={lightRef}
          intensity={3}
          distance={25}
          decay={2}
        />
      );
    }
    ```

    This component dynamically adjusts a point light's position and color based on mouse movement, creating an interactive lighting effect that responds to user input.

    [View on GitHub](https://github.com/santrupt29/portfolio/blob/main/src/components/InteractiveBackgroundScene.jsx)

## Mermaid Diagrams

1.  **Interactive Flow**

    



```mermaid
    graph LR
        A["Mouse Movement"] --> B{"Calculate Cursor Position"};
        B --> C{"Update Object Properties"};
        C --> D["Rotation"];
        C --> E["Scale"];
        C --> F["Color"];
        D --> G("3D Object");
        E --> G;
        F --> G;
    ```



2.  **Shape Generation**

    



```mermaid
    graph TD
        A["Shape Type Selection"] --> B{{"Switch Statement"}};
        B --> |"icosphere"| C["IcosahedronGeometry"];
        B --> |"code_bracket"| D["ExtrudeGeometry"];
        B --> |"lightbulb"| E["SphereGeometry"];
        C --> F("Geometry Output");
        D --> F;
        E --> F;
    ```



## Key Integration Points

*   **React Three Fiber Integration:** The use of React Three Fiber simplifies the management of Three.js elements within a React component structure. This approach enhances code readability and maintainability.
*   **Performance Optimization:** Balancing the number of particles, the complexity of geometries, and the use of post-processing effects is crucial for maintaining smooth performance, especially on lower-end devices. Consider using techniques like LOD (Level of Detail) for more complex geometries.
*   **Interactivity Considerations:** Careful design of interactive elements ensures a seamless and engaging user experience without causing performance bottlenecks. Debouncing mouse events can help reduce the frequency of updates.
*   **Code Reusability:** Encapsulating common patterns, such as the creation of shapes, lighting setups, and post-processing effects, into reusable components promotes code efficiency and reduces redundancy.
```