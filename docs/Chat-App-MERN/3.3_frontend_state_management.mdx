---
title: "Frontend State Management"
description: "Explains how global application state for authentication, chat, and themes is managed using Zustand stores."
---

# Frontend State Management
<TOC />

Managing application state effectively is crucial for a smooth user experience, especially in real-time applications like chat. This project leverages **Zustand**, a small, fast, and scalable bear-necessities state-management solution, to handle global application state for authentication, chat, and theme settings.

Zustand stores are lightweight, hook-based, and provide a clear separation of concerns, making the state logic testable and maintainable. Each store encapsulates specific domain logic and the data associated with it.

## 1. Authentication State (`useAuthStore`)

The `useAuthStore` manages all user-related state, including the authenticated user's data, authentication status, and integration with a WebSocket for online user tracking.

**File:** `frontend/src/store/useAuthStore.js`

**Key State Properties:**
*   `authUser`: The currently authenticated user object. `null` if not logged in.
*   `isLoggingIn`, `isSigningUp`, `isUpdatingProfile`, `isCheckingAuth`: Boolean flags to indicate the loading status of various authentication operations.
*   `onlineUsers`: An array of user IDs currently online, received via WebSocket.
*   `socket`: The WebSocket client instance, used for real-time communication (e.g., online status updates).

**Key Actions:**
*   `checkAuth()`: Verifies the user's authentication status on application load.
*   `login(data)`, `signup(data)`: Handles user authentication and account creation, respectively.
*   `logout()`: Clears the authenticated user state and disconnects the WebSocket.
*   `updateProfile(data)`: Updates the authenticated user's profile information.
*   `connectSocket()`, `disconnectSocket()`: Manages the WebSocket connection lifecycle.

**Usage Example: `LoginPage.jsx`**
The `LoginPage` component utilizes `useAuthStore` to handle user login.

```jsx title="frontend/src/pages/LoginPage.jsx"
import { useState } from "react"
import { useAuthStore } from "../store/useAuthStore";
// ... (other imports)

const LoginPage = () => {
  const [formData, setFormData] = useState({
    email: "",
    password: "",
  })
  const { login, isLoggingIn } = useAuthStore(); // <-- Consuming login and isLoggingIn

  const handleSubmit = async (e) => {
    e.preventDefault();
    login(formData); // <-- Calling the login action
  }
  // ...
  return (
    // ...
            <button type="submit" className="btn btn-primary w-full" disabled={isLoggingIn}>
              {isLoggingIn ? ( // <-- Using isLoggingIn for UI feedback
                <>
                  <Loader2 className="h-5 w-5 animate-spin" />
                  Loading...
                </>
              ) : (
                "Sign in"
              )}
            </button>
    // ...
  )
}
export default LoginPage
```
<p>
    <a href="https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/pages/LoginPage.jsx" target="_blank" rel="noopener noreferrer">Source</a>
</p>

**Usage Example: `Navbar.jsx`**
The `Navbar` component displays user-specific actions like "Profile" and "Logout" based on `authUser` and provides the `logout` functionality.

```jsx title="frontend/src/components/Navbar.jsx"
import { Link } from "react-router-dom";
import { useAuthStore } from "../store/useAuthStore"; // <-- Importing useAuthStore
import { LogOut, MessageSquare, Settings, User, Users } from "lucide-react";
import { useChatStore } from "../store/useChatStore";

const Navbar = () => {
  const { logout, authUser } = useAuthStore(); // <-- Consuming logout and authUser
  const { toggleFriendsBox } = useChatStore(); 

  return (
    // ...
            {authUser && ( // <-- Conditionally rendering based on authUser
              <>
                <Link to={"/profile"} className={`btn btn-sm gap-2`}>
                  <User className="size-5" />
                  <span className="hidden sm:inline">Profile</span>
                </Link>

                <button className="btn btn-sm flex gap-2 items-center" onClick={logout}> {/* <-- Calling logout */}
                  <LogOut className="size-5" />
                  <span className="hidden sm:inline">Logout</span>
                </button>
              </>
            )}
    // ...
  );
};

export default Navbar;
```
<p>
    <a href="https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Navbar.jsx" target="_blank" rel="noopener noreferrer">Source</a>
</p>

## 2. Chat State (`useChatStore`)

The `useChatStore` manages all chat-specific data, including messages, users in the chat list, selected conversations, and loading states. It also handles real-time message updates via WebSocket subscriptions.

**File:** `frontend/src/store/useChatStore.js` (Partial content provided, inferred from usage)

**Key State Properties:**
*   `messages`: An array of messages for the currently selected chat.
*   `users`: A list of all available users for chat.
*   `pendingRequests`, `sentRequests`: Arrays to manage friend requests.
*   `selectedUser`: The user object for the currently active chat conversation.
*   `isUsersLoading`, `isMessagesLoading`: Boolean flags for loading statuses.

**Key Actions (Inferred from usage):**
*   `getMessages(userId)`: Fetches messages for a specific user.
*   `subscribeToMessages()`, `unsubscribeFromMessages()`: Manages WebSocket subscriptions for real-time message updates.
*   `toggleFriendsBox()`: Toggles the visibility of the friends list.

**Usage Example: `ChatContainer.jsx`**
The `ChatContainer` component is the primary consumer of `useChatStore`, managing message display, fetching, and real-time updates. It also uses `useAuthStore` to determine if a message was sent by the current user.

```jsx title="frontend/src/components/ChatContainer.jsx"
import { useEffect } from "react";
import { useChatStore } from "../store/useChatStore"; // <-- Importing useChatStore
import { useAuthStore } from "../store/useAuthStore"; // <-- Importing useAuthStore
// ... (other imports)

const ChatContainer = () => {
    const { messages, getMessages, isMessagesLoading, selectedUser, subscribeToMessages, unsubscribeFromMessages } =
        useChatStore(); // <-- Consuming chat state and actions
    const { authUser } = useAuthStore(); // <-- Consuming authUser for message display
    const messageEndRef = useRef(null);


    useEffect(() => {
        getMessages(selectedUser._id); // <-- Fetching messages
        subscribeToMessages(); // <-- Subscribing to real-time updates

        return () => unsubscribeFromMessages(); // <-- Unsubscribing on unmount/dependency change
    }, [selectedUser._id, getMessages, subscribeToMessages, unsubscribeFromMessages]);
    
    useEffect(() => {
        if(messageEndRef.current && messages){
            messageEndRef.current.scrollIntoView({behaviour : "smooth"})
        }
    }, [messages])

    if (isMessagesLoading) // <-- Using loading state for UI feedback
        return (
            <div className="flex-1 flex flex-col overflow-auto">
                <ChatHeader />
                <MessageSkeleton />
                <MessageInput />
            </div>
        );
    return (
        <div className="flex-1 flex flex-col overflow-auto">
            <ChatHeader />
            <div className="flex-1 overflow-y-auto p-4 space-y-4">
                {messages.map((message) => ( // <-- Mapping through messages
                    <div
                        key={message._id}
                        className={`chat ${message.senderId == authUser._id ? "chat-end": "chat-start"} `} // <-- Using authUser to style messages
                        ref={messageEndRef}
                    >
                        {/* ... message content ... */}
                    </div>
                ))}
            </div>
            <MessageInput />
        </div>
    );
};

export default ChatContainer;
```
<p>
    <a href="https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/ChatContainer.jsx" target="_blank" rel="noopener noreferrer">Source</a>
</p>

**Usage Example: `Navbar.jsx`**
The `Navbar` also uses `useChatStore` to provide a button to toggle the friends list visibility.

```jsx title="frontend/src/components/Navbar.jsx"
// ... (other imports)
import { useChatStore } from "../store/useChatStore"; // <-- Importing useChatStore

const Navbar = () => {
  const { logout, authUser } = useAuthStore();
  const { toggleFriendsBox } = useChatStore(); // <-- Consuming toggleFriendsBox

  return (
    // ...
          <div className="flex items-center gap-4">
            <button className="btn btn-sm gap-2" onClick={toggleFriendsBox}> {/* <-- Calling toggleFriendsBox */}
              <Users className="size-5" />
              <span className="hidden sm:inline">Friends</span>
            </button>
    // ...
  );
};
export default Navbar;
```
<p>
    <a href="https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Navbar.jsx" target="_blank" rel="noopener noreferrer">Source</a>
</p>

## 3. Theme State (`useThemeStore`)

While the file content for `frontend/src/store/useThemeStore.js` was not provided, based on the project description, it would typically manage the application's theme (e.g., dark mode, light mode). It would expose state like `theme` (a string) and actions like `setTheme(newTheme)` to allow components to read and update the current theme preference.

<p>
    <a href="https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/store/useThemeStore.js" target="_blank" rel="noopener noreferrer">Source</a>
</p>

## Global State Flow

The following diagram illustrates how different frontend components interact with the Zustand stores to manage global application state.

````mermaid
graph TD
    subgraph Frontend Components
        A[LoginPage]
        B[Navbar]
        C[ChatContainer]
        D[SettingsPage (Example for Theme)]
    end

    subgraph Zustand Stores
        E[useAuthStore]
        F[useChatStore]
        G[useThemeStore]
    end

    A -- "Calls login() with credentials" --> E
    A -- "Reads isLoggingIn" --> E

    B -- "Reads authUser, onlineUsers" --> E
    B -- "Calls logout()" --> E
    B -- "Calls toggleFriendsBox()" --> F

    C -- "Reads authUser (for sender identification)" --> E
    C -- "Reads messages, selectedUser, isMessagesLoading" --> F
    C -- "Calls getMessages(), subscribeToMessages(), unsubscribeFromMessages()" --> F

    D -- "Reads theme" --> G
    D -- "Calls setTheme()" --> G
```

This clear separation allows for efficient state management, promoting maintainable and scalable code. Each store acts as a single source of truth for its specific domain, and components can subscribe to only the parts of the state they need, triggering re-renders only when necessary.

Next: [Frontend Utilities & Constants](./3.4_frontend_utilities_constants.mdx)