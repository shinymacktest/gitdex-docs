---
title: "Frontend Components and Pages"
description: "Description of key reusable UI components and the main application pages."
sidebar_position: 31
---

# Frontend Components and Pages

<TOC />

This section delves into the core UI components and pages that form the user interface of the chat application. We'll explore how these components interact, manage state, and render dynamic content to provide a seamless user experience. The primary focus is on the `HomePage`, which serves as the application's main canvas, and key reusable components such as `ChatContainer`, `MessageInput`, and `Sidebar`.

## HomePage: The Application's Main Layout

The `HomePage` component is the orchestrator of the chat application's user interface. It is responsible for laying out the main structural elements: the `Sidebar` for user selection, the `ChatContainer` (or `NoChatSelected` placeholder) for message display, and conditionally, the `FriendsBox`. This component dynamically renders the chat interface based on the user's selection, ensuring a responsive and intuitive layout.

**Key Features:**

*   **Conditional Rendering:** It intelligently switches between displaying the `ChatContainer` and a `NoChatSelected` component based on whether a user has been selected for a chat.
*   **Layout Management:** Defines the overall structure, ensuring the sidebar and chat area are properly positioned within the application's viewport.

```jsx
// frontend/src/pages/HomePage.jsx
import ChatContainer from "../components/ChatContainer";
import FriendsBox from "../components/FriendsBox";
import NoChatSelected from "../components/NoChatSelected";
import Sidebar from "../components/Sidebar";
import { useChatStore } from "../store/useChatStore"

const HomePage = () => {
  const { selectedUser } = useChatStore();
  const { isFriendsBoxOpen } = useChatStore(); // For opening friends list
  return (
      <div className="h-screen bg-base-200">
      <div className="flex items-center justify-center pt-20 px-4 w-full">
        <div className="bg-base-100 rounded-lg shadow-xl w-full max-w-6xl h-[calc(100vh-8rem)]">
          <div className="flex h-full rounded-lg overflow-hidden w-full">
            <Sidebar />
            {!selectedUser ? <NoChatSelected /> : <ChatContainer />}
            {isFriendsBoxOpen && <FriendsBox />} 

          </div>

        </div>
      </div>
    </div>
  )
}

export default HomePage
```

This snippet illustrates the conditional rendering logic, where `ChatContainer` is only mounted if `selectedUser` is present.
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/pages/HomePage.jsx#L9-L29)

## Sidebar: User Navigation and Selection

The `Sidebar` component displays a list of available users (friends), allowing the authenticated user to select a recipient for a chat. It fetches user data, manages online/offline indicators, and provides a filter option to show only online friends.

**Key Features:**

*   **User Listing:** Displays all friends, including their profile pictures and usernames.
*   **Online Status Indicator:** Visually indicates which friends are currently online using a green dot.
*   **Filtering:** Allows users to filter the list to show only online friends, enhancing usability.
*   **User Selection:** Handles the selection of a chat partner, updating the global chat state.

```jsx
// frontend/src/components/Sidebar.jsx
import { useEffect, useState } from "react";
import { useChatStore } from "../store/useChatStore";
import SidebarSkeleton from "./skeletons/SidebarSkeleton";
import { Users } from "lucide-react";
import { useAuthStore } from "../store/useAuthStore";

const Sidebar = () => {
    const { getFriends, users, selectedUser, setSelectedUser, isUsersLoading } =
        useChatStore();

    const { onlineUsers } = useAuthStore();
    const [showOnlineOnly, setShowOnlineOnly] = useState(false);
    useEffect(() => {
        getFriends(); // Fetches friends on component mount
    }, [getFriends]);
    const filteredUsers = showOnlineOnly
        ? users.filter((user) => onlineUsers.includes(user._id))
        : users;
    // ... rest of the component
```

Here, `useEffect` is used to fetch the list of friends when the `Sidebar` component mounts. The `useChatStore` and `useAuthStore` are utilized to retrieve friend data, manage selected users, and access online status information.
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Sidebar.jsx#L8-L24)

The rendering logic for individual users includes a dynamic class for highlighting the `selectedUser` and a conditional span for the online indicator.

```jsx
// frontend/src/components/Sidebar.jsx (inside return statement)
// ...
{filteredUsers.map((user) => (
    <button
        key={user._id}
        onClick={() => setSelectedUser(user)} // Sets the selected user in the chat store
        className={`sm:w-full w-[88vw] p-3 flex items-center gap-3 hover:bg-base-300 transition-colors
        ${
            selectedUser?._id === user._id
                ? "bg-base-300 ring-1 ring-base-300"
                : ""
        }`}
    >
        <div className="relative mx-0">
            <img
                src={user.profilePic || "/avatar.png"}
                alt={user.username}
                className="size-12 object-cover rounded-full"
            />
            {onlineUsers.includes(user._id) && ( // Online indicator
                <span className="absolute bottom-0 right-0 size-3 bg-green-500 rounded-full ring-2 ring-zinc-900" />
            )}
        </div>
        <div className=" block text-left min-w-0">
            <div className=" font-medium truncate">
                {user.username}
            </div>
            <div className="text-sm text-zinc-400">
                {onlineUsers.includes(user._id)
                    ? "Online"
                    : "Offline"}
            </div>
        </div>
    </button>
))}
// ...
```
This demonstrates how `setSelectedUser` from `useChatStore` updates the global state, triggering UI changes in `HomePage` (e.g., displaying `ChatContainer`).
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Sidebar.jsx#L59-L93)

## ChatContainer: Displaying Messages

The `ChatContainer` component is responsible for displaying the chat history for the currently `selectedUser`. It fetches messages, subscribes to real-time updates, and renders each message with sender information, timestamps, and media attachments.

**Key Features:**

*   **Message Fetching:** Retrieves chat messages for the selected user using `getMessages` from `useChatStore`.
*   **Real-time Updates:** Subscribes to new messages via `subscribeToMessages` to ensure the chat view is always up-to-date.
*   **Message Rendering:** Displays individual messages, distinguishing between sent and received messages.
*   **Auto-scrolling:** Automatically scrolls to the latest message using a `useRef` hook.
*   **Media Display:** Renders image attachments within messages.

```jsx
// frontend/src/components/ChatContainer.jsx
import { useEffect } from "react";
import { useChatStore } from "../store/useChatStore";
import ChatHeader from "./ChatHeader";
import MessageInput from "./MessageInput";
import MessageSkeleton from "./skeletons/MessageSkeleton";
import { useAuthStore } from "../store/useAuthStore";
import { formatMessageTime } from "../lib/utils";
import { useRef } from "react";

const ChatContainer = () => {
    const { messages, getMessages, isMessagesLoading, selectedUser, subscribeToMessages, unsubscribeFromMessages } =
        useChatStore();
    const { authUser } = useAuthStore();
    const messageEndRef = useRef(null);


    useEffect(() => {
        getMessages(selectedUser._id); // Fetch messages for the selected user
        subscribeToMessages(); // Start listening for new messages

        return () => unsubscribeFromMessages(); // Clean up subscription
    }, [selectedUser._id, getMessages, subscribeToMessages, unsubscribeFromMessages]);
    
    useEffect(() => {
        if(messageEndRef.current && messages){
            messageEndRef.current.scrollIntoView({behaviour : "smooth"}) // Scroll to bottom on new messages
        }
    }, [messages])
    // ... rest of the component
```
The two `useEffect` hooks manage message fetching, real-time subscriptions, and auto-scrolling to the latest message. The dependency arrays ensure these effects re-run appropriately.
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/ChatContainer.jsx#L11-L29)

Messages are rendered dynamically, with conditional styling to differentiate between `chat-end` (sender's messages) and `chat-start` (receiver's messages).

```jsx
// frontend/src/components/ChatContainer.jsx (inside return statement)
// ...
<div className="flex-1 overflow-y-auto p-4 space-y-4">
    {messages.map((message) => (
        <div
            key={message._id}
            className={`chat ${message.senderId == authUser._id ? "chat-end": "chat-start"} `} // Conditional styling
            ref={messageEndRef} // Ref for auto-scrolling
        >
            <div className="chat-image avatar">
                <div className="size-9 rounded-full border">
                    <img
                        src={message.senderId == authUser._id ? authUser.profilePic || "/avatar.png": selectedUser.profilePic || "/avatar.png"}
                        alt="profilepic"
                     />
                </div>
            </div>
            <div className="chat-header mb-1">
                <time className="text-xs opacity-50 ml-1">{formatMessageTime(message.createdAt)}</time>
            </div>
            <div className="chat-bubble flex flex-col">
                {message.image && ( // Display image if present
                    <img 
                        src={message.image}
                        alt="Attachment"
                        className="sm:max-w-[200px] rounded-md " 
                    />
                )}
                {message.text && <p>{message.text}</p>} {/* Display text if present */}
            </div>
        </div>
    ))}
</div>
// ...
```
This loop maps through the `messages` array, rendering each one. Profile pictures are conditionally displayed based on whether the `authUser` or `selectedUser` sent the message.
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/ChatContainer.jsx#L38-L72)

## MessageInput: Sending Messages and Media

The `MessageInput` component provides the interface for users to compose and send messages, including text and image attachments. It integrates with the chat store to dispatch messages and handles local image previews.

**Key Features:**

*   **Text Input:** A standard text area for composing messages.
*   **Image Attachment:** Allows users to select an image, preview it, and send it along with the message.
*   **Image Preview and Removal:** Displays a preview of the selected image and provides an option to remove it before sending.
*   **Message Dispatch:** Uses the `sendMessage` action from `useChatStore` to send the composed message and/or image.
*   **Validation:** Prevents sending empty messages.

```jsx
// frontend/src/components/MessageInput.jsx
import { useRef, useState } from "react";
import { useChatStore } from "../store/useChatStore";
import { Image, Send, X } from "lucide-react";
import toast from "react-hot-toast";

const MessageInput = () => {
    const [text, setText] = useState("");
    const [imagePreview, setImagePreview] = useState(null);
    const fileInputRef = useRef(null);
    const { sendMessage } = useChatStore(); // Action to send messages

    const handleImageChange = (e) => {
        const file = e.target.files[0];
        if (!file.type.startsWith("image/")) {
            toast.error("Please select an image file");
            return;
        }

        const reader = new FileReader();
        reader.onloadend = () => {
            setImagePreview(reader.result); // Set image preview
        };
        reader.readAsDataURL(file);
    };
    // ... rest of the component
```
This section highlights the state management for text and image preview, as well as the `handleImageChange` function which reads the selected image file and sets up a data URL for preview.
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/MessageInput.jsx#L8-L29)

The `handleSendMessage` function orchestrates the actual sending process:

```jsx
// frontend/src/components/MessageInput.jsx
// ...
const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!text.trim() && !imagePreview) return; // Prevent sending empty

    try {
        await sendMessage({ // Call the store action
            text: text.trim(),
            image: imagePreview,
        });

        setText(""); // Clear input
        setImagePreview(null); // Clear preview
        if (fileInputRef.current) fileInputRef.current = "";
    } catch (error) {
        console.error("Failed to send message", error);
    }
};
// ...
```
This asynchronous function demonstrates how `sendMessage` from `useChatStore` is called with the message content and image. Post-send, the input fields are cleared.
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/MessageInput.jsx#L41-L57)

## Component Interaction Diagram

The following diagram illustrates how the main frontend components interact with each other and with the shared state management.





```mermaid
graph TD
    A["HomePage"] --> B["Sidebar"];
    A --> C["ChatContainer"];
    A --> D["NoChatSelected"];
    B -->|Calls setSelectedUser(Zustand)| E["ChatStore"];
    C -->|Calls getMessages, subscribeToMessages(Zustand)| E;
    F["MessageInput"] -->|Calls sendMessage(Zustand)| E;
    B -->|Accesses onlineUsers(Zustand)| G["AuthStore"];
    C -->|Accesses authUser(Zustand)| G;
    E --> C;
    E --> B;
    G --> B;
    G --> C;
```



## Key Integration Points

The frontend components heavily rely on the **Zustand store** (`useChatStore`, `useAuthStore`) for managing application state. This centralized state management allows for seamless communication and data flow between components:

1.  **User Selection:** When a user clicks on a friend in the `Sidebar`, `setSelectedUser` in `useChatStore` is called. This update triggers `HomePage` to render `ChatContainer` (instead of `NoChatSelected`).
2.  **Message Flow:**
    *   `ChatContainer` observes `selectedUser` changes and calls `getMessages` to fetch historical messages.
    *   `ChatContainer` subscribes to real-time message updates (`subscribeToMessages`) from the WebSocket connection, which updates the `messages` array in `useChatStore`.
    *   `MessageInput` uses `sendMessage` to dispatch new messages (text and/or image) to the backend via an API call, which then updates the `messages` in `useChatStore` upon successful delivery (and likely triggers the WebSocket to inform other clients).
3.  **Online Status:** Both `Sidebar` and `ChatContainer` consume the `onlineUsers` array from `useAuthStore` to display real-time online indicators. This information is typically populated via WebSocket events upon user connection/disconnection.
4.  **Auto-scrolling:** The `ChatContainer` employs a `useRef` and `useEffect` hook to automatically scroll to the latest message whenever the `messages` array is updated, enhancing user experience.

These components demonstrate a clear separation of concerns, with each handling a specific part of the UI while collaborating through shared state, providing a robust and maintainable frontend architecture.

Next: [State Management and Utilities](./3.2_state-management-and-utilities.mdx)