---
title: "Core Components and Layouts"
description: "Describes the major React components that form the application's user interface and overall layout."
sidebar_position: 31
---
 # Core Components and Layouts

This section details the primary React components that structure the ShinyChat application's user interface, defining its overall layout and core functionalities. These components are responsible for rendering chat conversations, managing user interactions, and providing essential navigation.

## Navbar

The `Navbar` component serves as the application's global header, offering consistent navigation and access to key features across different views. It remains fixed at the top, providing quick access to friends, settings, profile, and logout functionality.

- **Location:** `frontend/src/components/Navbar.jsx`
- **Purpose:** Global navigation, branding, and access to user-specific actions.
- **Key Features:**
    - **Branding:** Displays the application logo and name, `ShinyChat`.
    - **Friends Toggle:** A button that interacts with the global chat store to toggle the visibility of the `Sidebar` (friends list).
    - **Navigation Links:** Provides links to `Settings` and, for authenticated users, `Profile`.
    - **Logout:** A button that triggers the `logout` action from the authentication store.
    - **Conditional Rendering:** Dynamically shows `Profile` and `Logout` options only when a user is authenticated.
    - **Sticky Header:** Uses CSS classes like `fixed`, `top-0`, `w-full` to ensure it's always visible at the top.

The `Navbar` relies on the `useAuthStore` to determine the authentication status and `useChatStore` to manage the friends box visibility.

```jsx
import { Link } from "react-router-dom";
import { useAuthStore } from "../store/useAuthStore";
import { LogOut, MessageSquare, Settings, User, Users } from "lucide-react";
import { useChatStore } from "../store/useChatStore";

const Navbar = () => {
  const { logout, authUser } = useAuthStore();
  const { toggleFriendsBox } = useChatStore(); 

  return (
    <header
      className=" bg-base-100 border-b border-base-300 fixed w-full top-0 z-40
        backdrop-blur-lg bg-base-100/80"
    >
      <div className="container mx-auto px-4 h-16">
        <div className="flex items-center justify-between h-full">
          <div className="flex items-center gap-8">
            <Link
              to="/"
              className="flex items-center gap-2.5 hover:opacity-80 transition-all"
            >
              <div className="size-9 rounded-lg bg-primary/10 flex items-center justify-center">
                <MessageSquare className="size-5 text-primary"></MessageSquare>
              </div>
              <h1 className="text-lg font-bold">ShinyChat</h1>
            </Link>
          </div>
          <div className="flex items-center gap-4">
            <button className="btn btn-sm gap-2" onClick={toggleFriendsBox}>
              <Users className="size-5" />
              <span className="hidden sm:inline">Friends</span>
            </button>
            {/* ... other links and logout button ... */}
          </div>
        </div>
      </div>
    </header>
  );
};

export default Navbar;
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Navbar.jsx#L1-L50)

This snippet illustrates the core structure including the branding, the "Friends" button that triggers `toggleFriendsBox` from `useChatStore`, and the overall layout. The conditional rendering for authenticated user links is also a critical part of this component.

## Sidebar

The `Sidebar` component displays a list of the user's friends, allowing them to select a conversation partner. It includes features for filtering friends based on their online status.

- **Location:** `frontend/src/components/Sidebar.jsx`
- **Purpose:** Display and manage the list of friends for chat selection.
- **Key Features:**
    - **Friends List Fetching:** Utilizes `useChatStore` to fetch and display the current user's friends.
    - **User Selection:** Allows users to select a friend, which updates the `selectedUser` in the global chat store, triggering the display of their chat messages in `ChatContainer`.
    - **Online Status Indicator:** Visually shows if a friend is online or offline using a green dot and text label. This relies on `onlineUsers` from `useAuthStore`.
    - **Online Filter:** A checkbox to filter the displayed friends, showing only those who are currently online.
    - **Responsive Design:** Adjusts its visibility based on whether a `selectedUser` is active on smaller screens, allowing the `ChatContainer` to take precedence.
    - **Loading Skeleton:** Displays `SidebarSkeleton` while friends are being loaded.

The `Sidebar` is a crucial navigation element for initiating and switching conversations. Its responsiveness ensures a good user experience across different screen sizes.

```jsx
import { useEffect, useState } from "react";
import { useChatStore } from "../store/useChatStore";
import SidebarSkeleton from "./skeletons/SidebarSkeleton";
import { Users } from "lucide-react";
import { useAuthStore } from "../store/useAuthStore";

const Sidebar = () => {
    const { getFriends, users, selectedUser, setSelectedUser, isUsersLoading } =
        useChatStore();
    const { onlineUsers } = useAuthStore();
    const [showOnlineOnly, setShowOnlineOnly] = useState(false);

    useEffect(() => {
        getFriends();
    }, [getFriends]);

    const filteredUsers = showOnlineOnly
        ? users.filter((user) => onlineUsers.includes(user._id))
        : users;

    if (isUsersLoading) return <SidebarSkeleton />;

    return (
        <div className={`h-full sm:w-72 sm:border-r border-base-300  flex-col transition-all duration-200 ${selectedUser ?
                                    "hidden sm:flex w-[100vw] "
                                    : ""}`}>
            {/* ... online filter and friends list rendering ... */}
            <div className="overflow-y-scroll h-[calc(100vh-14rem)] w-full flex flex-col py-3">
                {filteredUsers.map((user) => (
                    <button
                        key={user._id}
                        onClick={() => setSelectedUser(user)}
                        className={`sm:w-full w-[88vw] p-3 flex items-center gap-3 hover:bg-base-300 transition-colors
                        ${selectedUser?._id === user._id ? "bg-base-300 ring-1 ring-base-300" : ""}`}
                    >
                        <div className="relative mx-0">
                            <img
                                src={user.profilePic || "/avatar.png"}
                                alt={user.username}
                                className="size-12 object-cover rounded-full"
                            />
                            {onlineUsers.includes(user._id) && (
                                <span className="absolute bottom-0 right-0 size-3 bg-green-500 rounded-full ring-2 ring-zinc-900" />
                            )}
                        </div>
                        <div className=" block text-left min-w-0">
                            <div className=" font-medium truncate">{user.username}</div>
                            <div className="text-sm text-zinc-400">
                                {onlineUsers.includes(user._id) ? "Online" : "Offline"}
                            </div>
                        </div>
                    </button>
                ))}
            </div>
            {filteredUsers.length == 0 && (
                <div className="text-center text-zinc-500 py-4">No online friends</div>
            )}
        </div>
    );
};

export default Sidebar;
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Sidebar.jsx#L1-L76)

The `useEffect` hook initiates fetching of friends. The `filteredUsers` array is dynamically populated based on the `showOnlineOnly` state and `onlineUsers` from the authentication store. Each user entry is a clickable button that sets the `selectedUser` in `useChatStore`.

## ChatContainer

The `ChatContainer` component is the heart of the messaging interface. It displays the message history for the currently selected user and manages real-time message updates.

- **Location:** `frontend/src/components/ChatContainer.jsx`
- **Purpose:** Display ongoing chat conversations with a selected user.
- **Key Features:**
    - **Dynamic Message Loading:** Fetches messages for the `selectedUser` using `getMessages` from `useChatStore`.
    - **Real-time Updates:** Subscribes to and unsubscribes from WebSocket messages via `subscribeToMessages` and `unsubscribeFromMessages` in `useChatStore` for live message reception.
    - **Message Display:** Renders individual chat bubbles, distinguishing between messages sent by the authenticated user (`chat-end`) and the selected user (`chat-start`).
    - **Image Support:** Displays attached images within the chat bubbles.
    - **Auto-Scroll:** Automatically scrolls to the latest message using a `useRef` hook.
    - **Loading Skeleton:** Shows `MessageSkeleton` while messages are loading.
    - **Message Input Integration:** Renders the `MessageInput` component at the bottom for sending new messages.

The `ChatContainer` orchestrates the display of messages and ensures a smooth, real-time chat experience.

```jsx
import { useEffect } from "react";
import { useChatStore } from "../store/useChatStore";
import ChatHeader from "./ChatHeader";
import MessageInput from "./MessageInput";
import MessageSkeleton from "./skeletons/MessageSkeleton";
import { useAuthStore } from "../store/useAuthStore";
import { formatMessageTime } from "../lib/utils";
import { useRef } from "react";

const ChatContainer = () => {
    const { messages, getMessages, isMessagesLoading, selectedUser, subscribeToMessages, unsubscribeFromMessages } =
        useChatStore();
    const { authUser } = useAuthStore();
    const messageEndRef = useRef(null);

    useEffect(() => {
        getMessages(selectedUser._id);
        subscribeToMessages();
        return () => unsubscribeFromMessages();
    }, [selectedUser._id, getMessages, subscribeToMessages, unsubscribeFromMessages]);
    
    useEffect(() => {
        if(messageEndRef.current && messages){
            messageEndRef.current.scrollIntoView({behaviour : "smooth"})
        }
    }, [messages])

    if (isMessagesLoading)
        return (
            <div className="flex-1 flex flex-col overflow-auto">
                <ChatHeader />
                <MessageSkeleton />
                <MessageInput />
            </div>
        );
    return (
        <div className="flex-1 flex flex-col overflow-auto">
            <ChatHeader />
            <div className="flex-1 overflow-y-auto p-4 space-y-4">
                {messages.map((message) => (
                    <div
                        key={message._id}
                        className={`chat ${message.senderId == authUser._id ? "chat-end": "chat-start"} `}
                        ref={messageEndRef}
                    >
                        <div className="chat-image avatar">
                            <div className="size-9 rounded-full border">
                                <img
                                    src={message.senderId == authUser._id ? authUser.profilePic || "/avatar.png": selectedUser.profilePic || "/avatar.png"}
                                    alt="profilepic"
                                 />
                            </div>
                        </div>
                        <div className="chat-header mb-1">
                            <time className="text-xs opacity-50 ml-1">{formatMessageTime(message.createdAt)}</time>
                        </div>
                        <div className="chat-bubble flex flex-col">
                            {message.image && (
                                <img 
                                    src={message.image}
                                    alt="Attachment"
                                    className="sm:max-w-[200px] rounded-md " 
                                />
                            )}
                            {message.text && <p>{message.text}</p>}
                        </div>
                    </div>
                ))}
            </div>
            <MessageInput />
        </div>
    );
};

export default ChatContainer;
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/ChatContainer.jsx#L1-L82)

The first `useEffect` handles fetching messages for the currently `selectedUser` and sets up real-time message subscriptions. The second `useEffect` ensures the chat view always scrolls to the newest message. Message bubbles are dynamically styled based on the sender.

## MessageInput

The `MessageInput` component provides the interface for users to compose and send messages, including text and image attachments.

- **Location:** `frontend/src/components/MessageInput.jsx`
- **Purpose:** Allow users to type text messages and attach images.
- **Key Features:**
    - **Text Input:** A text field for typing messages, managed by local state.
    - **Image Attachment:** A button to open a file input, allowing users to select an image.
    - **Image Preview:** Displays a preview of the selected image before sending, with an option to remove it.
    - **Sending Logic:** Triggers the `sendMessage` function from `useChatStore` when the form is submitted.
    - **Validation:** Ensures that either text or an image (or both) is present before allowing a message to be sent.
    - **Toast Notifications:** Uses `react-hot-toast` to provide feedback (e.g., for invalid file types).

This component is the primary interaction point for users to contribute to a conversation.

```jsx
import { useRef, useState } from "react";
import { useChatStore } from "../store/useChatStore";
import { Image, Send, X } from "lucide-react";
import toast from "react-hot-toast";

const MessageInput = () => {
    const [text, setText] = useState("");
    const [imagePreview, setImagePreview] = useState(null);
    const fileInputRef = useRef(null);
    const { sendMessage } = useChatStore();

    const handleImageChange = (e) => {
        const file = e.target.files[0];
        if (!file.type.startsWith("image/")) {
            toast.error("Please select an image file");
            return;
        }
        const reader = new FileReader();
        reader.onloadend = () => {
            setImagePreview(reader.result);
        };
        reader.readAsDataURL(file);
    };

    const removeImage = () => {
        setImagePreview(null);
        if (fileInputRef.current) fileInputRef.current.value = "";
    };

    const handleSendMessage = async (e) => {
        e.preventDefault();
        if (!text.trim() && !imagePreview) return;
        try {
            await sendMessage({
                text: text.trim(),
                image: imagePreview,
            });
            setText("");
            setImagePreview(null);
            if (fileInputRef.current) fileInputRef.current = "";
        } catch (error) {
            console.error("Failed to send message", error);
        }
    };

    return (
        <div className="p-4 w-full">
            {imagePreview && (
                <div className="mb-3 flex items-center gap-2">
                    <div className="relative">
                        <img
                            src={imagePreview}
                            alt="Preview"
                            className="w-20 h-20 object-cover rounded-lg border border-zinc-700"
                        />
                        <button
                            onClick={removeImage}
                            className="absolute -top-1.5 -right-1.5 w-5 h-5 rounded-full bg-base-300
              flex items-center justify-center"
                            type="button"
                        >
                            <X className="size-3" />
                        </button>
                    </div>
                </div>
            )}
            <form onSubmit={handleSendMessage} className="flex items-center gap-2">
                <div className="flex flex-1 gap-2">
                    <input
                        type="text"
                        className="w-full input input-bordered rounded-lg input-sm sm:input-md"
                        placeholder="Type a message..."
                        value={text}
                        onChange={(e) => setText(e.target.value)}
                    />
                    <input
                        type="file"
                        accept="image/*"
                        className="hidden"
                        ref={fileInputRef}
                        onChange={handleImageChange}
                    />
                    <button
                        type="button"
                        className={`hidden sm:flex btn btn-circle ${imagePreview ? "text-emerald-500" : "text-zinc-400"}`}
                        onClick={
                            () => {
                                if (fileInputRef.current) {
                                    fileInputRef.current.click();
                                } else {
                                    console.error("fileInputRef is not attached");
                                }
                        }
                        }
                    >
                        <Image size={20} />
                    </button>
                </div>
                <button
                    type="submit"
                    className="btn btn-sm btn-circle"
                    disabled={!text.trim() && !imagePreview}
                >
                    <Send size={22} />
                </button>
            </form>
        </div>
    );
};

export default MessageInput;
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/MessageInput.jsx#L1-L127)

This component uses `useState` for text and image preview management, `useRef` for the hidden file input, and `useChatStore` for the `sendMessage` action. The `handleImageChange` function reads the selected image as a Data URL for preview, and `handleSendMessage` dispatches the message data.

## Key Integration Points

These core components demonstrate a clear separation of concerns and robust integration through global state management (Zustand stores) and React's lifecycle methods.

1.  **State Management with Zustand:** `useAuthStore` and `useChatStore` are central to how these components communicate and share data. `Navbar` uses `authUser` and `logout`, `Sidebar` uses `users`, `selectedUser`, `onlineUsers`, `getFriends`, and `setSelectedUser`, while `ChatContainer` and `MessageInput` extensively use `messages`, `selectedUser`, `getMessages`, `sendMessage`, and WebSocket subscription functions. This centralized state ensures consistency and responsiveness across the application.

2.  **Real-time Communication:** The `ChatContainer`'s `useEffect` hooks for `subscribeToMessages` and `unsubscribeFromMessages` are critical for establishing and tearing down WebSocket connections. This allows messages to be pushed to the client in real time, enhancing the user experience.

3.  **Component Composition:** The application's layout is formed by composing these components. `Navbar` provides global navigation, `Sidebar` manages conversation selection, and `ChatContainer` (which includes `MessageInput`) handles the active chat experience. This modular approach makes the UI manageable and scalable.

4.  **User Experience Flow:**
    The user interaction flow is carefully designed:
    - User selects a friend from `Sidebar`.
    - `setSelectedUser` in `useChatStore` updates.
    - `ChatContainer` detects `selectedUser` change via `useEffect`.
    - `getMessages` fetches historical messages for the new `selectedUser`.
    - `subscribeToMessages` ensures real-time updates for the new chat.
    - `MessageInput` uses `sendMessage` to send new messages for the `selectedUser`.

Here's a simplified view of the component interactions for initiating a chat:





```mermaid
graph TD
    A["User Clicks Friend (Sidebar)"] --> B{ "setSelectedUser(friend)" };
    B --> C["useChatStore (selectedUser updated)"];
    C --> D["ChatContainer (detects selectedUser change)"];
    D --> E["getMessages(selectedUser._id)"];
    E --> F["subscribeToMessages()"];
    F --> G["Display Messages"];
    G --> H["MessageInput (available for new messages)"];
```



5.  **Responsiveness and Adaptability:** Components like `Sidebar` are designed with responsiveness in mind, conditionally hiding or showing based on screen size and selected chat state, ensuring a focused experience on mobile devices without losing functionality.

This architecture creates a dynamic and interactive chat application, with each component playing a vital role in the overall user interface and experience.