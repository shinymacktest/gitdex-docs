---
title: "Authentication and Authorization"
description: "Explanation of the authentication mechanisms, session management, and access control middleware."
sidebar_position: 23
---
 # Authentication and Authorization

This section details the robust authentication and authorization mechanisms implemented in the application, ensuring secure user access and data protection. It covers standard email/password authentication, Google OAuth integration, secure session management using JWTs, and middleware for protecting routes.

## User Registration and Login (Email/Password)

The application provides a standard email and password-based registration and login system. New users can sign up by providing a unique username, email, and a secure password. Existing users can log in using their registered credentials.

### User Registration (`signup`)

The `signup` controller handles the creation of new user accounts. It performs essential validations such as checking for required fields, username/password length, and uniqueness of email and username. Passwords are securely hashed using `bcryptjs` before being stored in the database. Upon successful registration, a JSON Web Token (JWT) is generated and set as an HTTP-only cookie, logging the user in automatically.

```javascript
// backend/src/controllers/auth.controller.js
export const signup = async (req, res) => {
    const {username, email, password} = req.body;
    try {
        // ... input validations ...

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        const newUser = new User({
            username,
            email,
            password: hashedPassword,
            authProvider: 'email'
        });
        if(newUser){
            generateToken(newUser._id, res); // Generates JWT and sets cookie
            await newUser.save();

            res.status(201).json({
                _id: newUser._id,
                username: newUser.username,
                email: newUser.email,   
                profilePic: newUser.profilePic,
                authProvider: newUser.authProvider
            });
        } else {
            res.status(400).json({message: "Invalid user data."});
        }
    } catch (error) {
        console.log("Error in signup controller", error.message)
        res.status(500).json({message: "Something went wrong."});
    }
};
```
[View `signup` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L7-L69)

### User Login (`login`)

The `login` controller verifies user credentials against the stored data. It fetches the user by email, checks if the password matches the hashed password, and if successful, generates a new JWT and sets it as an HTTP-only cookie for session management. It also handles cases where a user might try to log in with email/password if they originally signed up via Google.

```javascript
// backend/src/controllers/auth.controller.js
export const login = async (req, res) => {
    const {email, password} = req.body;
    try {
        const user = await User.findOne({email});

        if(!user) {
            return res.status(400).json({message: "Invalid credentials."});
        }

        if(user.authProvider === 'google' && !user.password){
            return res.status(400).json({ message: "Please sign in with Google." });
        }

        const isPasswordCorrect = await bcrypt.compare(password, user.password);
        if(!isPasswordCorrect) {
            return res.status(400).json({message: "Invalid credentials."});
        }

        generateToken(user._id, res); // Generates JWT and sets cookie
        res.status(200).json({
            _id: user._id,
            username: user.username,
            email: user.email,
            profilePic: user.profilePic,
            authProvider: user.authProvider,
        });
    } catch (error) {
        console.log("Error in login controller", error.message);
        res.status(500).json({message: "Something went wrong."});
    }
};
```
[View `login` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L71-L109)

### Logout (`logout`)

To log out, the application clears the `jwt` cookie by setting its `maxAge` to 0, effectively invalidating the session on the client side.

```javascript
// backend/src/controllers/auth.controller.js
export const logout = (req, res) => {
    try {
        res.cookie("jwt", "", {maxAge: 0});
        res.status(200).json({message: "Logged out successfully."})
    } catch(error) {
        console.log("Error in logout controller", error.message);
        res.status(500).json({message:"Internal Server Error"}); 
    }
};
```
[View `logout` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L112-L121)

### Sequence Diagram: User Authentication Flow





```mermaid
sequenceDiagram
    participant C as "Client"
    participant B as "Backend Server"
    participant DB as "Database (MongoDB)"
    C->>+B: "POST /api/auth/signup (username, email, password)"
    B->>B: "Validate input"
    B->>DB: "Check existing user/email"
    alt User/Email Exists
        DB-->>B: "Error: User/Email taken"
        B->>-C: "400 Bad Request"
    else New User
        B->>B: "Hash Password (bcryptjs)"
        B->>DB: "Save New User (hashed password)"
        DB-->>B: "New User ID"
        B->>B: "Generate JWT & Set HTTP-only Cookie"
        B->>-C: "201 Created & User Data"
    end

    C->>+B: "POST /api/auth/login (email, password)"
    B->>DB: "Find User by Email"
    DB-->>B: "User Data (including hashed password)"
    B->>B: "Compare password (bcryptjs)"
    alt Invalid Credentials
        B->>-C: "400 Bad Request"
    else Valid Credentials
        B->>B: "Generate JWT & Set HTTP-only Cookie"
        B->>-C: "200 OK & User Data"
    end
```



## Session Management with JWT and Cookies

User sessions are managed using JSON Web Tokens (JWTs). Upon successful authentication (either signup or login), a JWT is generated and sent to the client as an HTTP-only cookie. This token contains the user's ID, which is used by the server to identify the user on subsequent requests.

The `generateToken` utility function is responsible for creating these JWTs and setting the cookie.

```javascript
// (Conceptual snippet from backend/src/lib/utils.js or similar)
// generateToken function, as used in auth.controller.js
import jwt from "jsonwebtoken";

const generateToken = (userId, res) => {
    const token = jwt.sign({ userId }, process.env.JWT_SECRET, {
        expiresIn: '15d',
    });

    res.cookie("jwt", token, {
        maxAge: 15 * 24 * 60 * 60 * 1000, // 15 days in milliseconds
        httpOnly: true, // Prevent XSS attacks
        sameSite: "strict", // CSRF protection
        secure: process.env.NODE_ENV !== "development", // Use HTTPS in production
    });
};
// This function is imported and used in auth.controller.js.
```
[View `generateToken` usage on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L54)

## Access Control Middleware (`protectRoute`)

The `protectRoute` middleware enforces access control by verifying the presence and validity of a JWT for protected routes. This middleware is crucial for ensuring that only authenticated users can access specific API endpoints.

It performs the following steps:
1.  **Extract Token**: Retrieves the JWT from the `jwt` HTTP-only cookie.
2.  **Verify Token**: Uses `jsonwebtoken.verify` to validate the token against the `JWT_SECRET`.
3.  **Find User**: Decodes the `userId` from the token and fetches the corresponding user from the database.
4.  **Attach User**: If valid, it attaches the `user` object (excluding the password) to the `req` object (`req.user`), making user information accessible to subsequent controllers.
5.  **Error Handling**: Returns `401 Unauthorized` for missing or invalid tokens, and `404 Not Found` if the user associated with the token does not exist.

```javascript
// backend/src/middleware/auth.middleware.js
import jwt from "jsonwebtoken"
import User from "../models/user.model.js"

export const protectRoute = async (req, res, next) => {
    try {
        const token = req.cookies.jwt;
        if(!token){
            return res.status(401).json({message: "Unauthorized - No Token Provided"});
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET)

        if(!decoded) {
            return res.status(401).json({message: "Unauthorized - Invalid Token"});
        }
        const user = await User.findById(decoded.userId).select("-password");

        if(!user) {
            return res.status(404).json({message: "User not found"});
        }
        req.user = user; // Attach user object to the request

        next(); // Proceed to the next middleware or controller
    } catch (error) {
        console.log("Error in protectRoute middleware", error.message);
        res.status(500).json({message: "Internal Server Error"});
    }
};
```
[View `protectRoute` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/middleware/auth.middleware.js#L3-L30)

### Check Authentication Status (`checkAuth`)

The `checkAuth` controller is a protected route that allows the client to verify if the user is currently authenticated and retrieve their basic profile information. It relies on the `protectRoute` middleware to populate `req.user`.

```javascript
// backend/src/controllers/auth.controller.js
export const checkAuth = (req, res) => {
    try {
        // req.user is populated by the protectRoute middleware
        res.status(200).json({
            _id: req.user._id,
            username: req.user.username,
            email: req.user.email,
            profilePic: req.user.profilePic,
            authProvider: req.user.authProvider,
            createdAt: req.user.createdAt
        });
    } catch (error) {
        console.log("Error in checkAuth controller", error.message);
        res.status(500).json({message: "Internal Server Error"});
    }
};
```
[View `checkAuth` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L124-L141)

### Sequence Diagram: Accessing a Protected Route





```mermaid
sequenceDiagram
    participant C as "Client"
    participant M as "Auth Middleware (protectRoute)"
    participant B as "Backend Server (Controller)"
    participant DB as "Database (MongoDB)"
    C->>+M: "Request to protected endpoint (with 'jwt' cookie)"
    M->>M: "Extract 'jwt' from cookie"
    alt No Token or Invalid Token
        M->>-C: "401 Unauthorized"
    else Valid Token
        M->>M: "Verify JWT (jsonwebtoken.verify)"
        M->>DB: "Find User by ID from JWT payload"
        DB-->>M: "User Data (excluding password)"
        alt User Not Found
            M->>-C: "404 Not Found"
        else User Found
            M->>M: "Attach User Data to req.user"
            M->>+B: "Call Controller Function"
            B->>B: "Process Request using req.user"
            B->>-C: "200 OK & Data"
        end
    end
```



## Google OAuth Integration

The application supports seamless authentication through Google using `passport.js` and `passport-google-oauth20`. This allows users to sign up or log in using their existing Google accounts, streamlining the user experience.

### Passport Configuration (`passport.config.js`)

The `configurePassport` function sets up the Google Strategy:
*   **GoogleStrategy**: Configured with `clientID`, `clientSecret`, `callbackURL`, and `scope` to request user profile and email.
*   **Verification Callback**: This asynchronous function is executed after Google authenticates the user. It checks if a user with the Google ID already exists.
    *   If the user exists, `done(null, user)` is called to log them in.
    *   If it's a new Google user, a new `User` document is created in the database, ensuring unique usernames (by appending a timestamp if needed), and then `done(null, newUser)` is called.
    *   It also handles cases where an email already exists but is not associated with Google OAuth, preventing account linking issues.
*   **Serialization/Deserialization**: `passport.serializeUser` stores only the user ID in the session, and `passport.deserializeUser` fetches the full user object from the database using that ID on subsequent requests, attaching it to `req.user`.

```javascript
// backend/src/lib/passport.config.js
import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import User from '../models/user.model.js'; 
import dotenv from 'dotenv';

dotenv.config(); 

export const configurePassport = () => {
    passport.use(new GoogleStrategy({
        clientID: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET,
        callbackURL: process.env.GOOGLE_CALLBACK_URL,
        scope: ['profile', 'email'] 
    },
    async (accessToken, refreshToken, profile, done) => {
        try {
            let user = await User.findOne({ googleId: profile.id });

            if (user) {
                return done(null, user);
            } else {
                // ... logic for creating a new user with unique username ...
                const newUser = new User({
                    googleId: profile.id,
                    email: profile.emails && profile.emails[0] ? profile.emails[0].value : null,
                    username: username, // dynamically generated unique username
                    authProvider: 'google',
                });
                // ... email validation and existing email checks ...
                await newUser.save();
                return done(null, newUser);
            }
        } catch (error) {
            return done(error, null);
        }
    }));

    passport.serializeUser((user, done) => {
        done(null, user.id);
    });

    passport.deserializeUser(async (id, done) => {
        try {
            const user = await User.findById(id);
            done(null, user);
        } catch (error) {
            done(error, null);
        }
    });
};
```
[View `passport.config` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/lib/passport.config.js#L5-L72)

### Google Auth Callback (`googleAuthCallback`)

After Google successfully authenticates the user and redirects to the `callbackURL`, this controller is invoked. If `req.user` is populated by Passport.js (indicating a successful authentication), a JWT is generated, and the user is redirected to the frontend application. If authentication fails, the user is redirected to the login page with an error message.

```javascript
// backend/src/controllers/auth.controller.js
export const googleAuthCallback = async (req, res) => {
 const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';

    try {
        if (!req.user) { // Passport.js populates req.user on successful auth
            return res.redirect(`${frontendUrl}/login?error=google_auth_failed`);
        }

        generateToken(req.user._id, res); // Generate JWT for the Google-authenticated user

        res.redirect(frontendUrl); // Redirect to frontend app

    } catch (error) {
        console.error("Error in googleAuthCallback: ", error.message);
        res.redirect(`${frontendUrl}/login?error=google_auth_processing_error`);
    }
};
```
[View `googleAuthCallback` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L144-L165)

## Profile Management

Users can update their profile information, such as their profile picture and username.

### Update Profile (`updateProfile`)

The `updateProfile` controller allows authenticated users to modify their profile details. It handles:
*   **Username Update**: Validates the new username for length and uniqueness (excluding the current user's ID).
*   **Profile Picture Update**: If a `profilePic` is provided (e.g., as a base64 string), it's uploaded to Cloudinary, and the secure URL is saved.
*   **Database Update**: Updates the user document in the database with the new details.
*   **Token Refresh**: A new JWT is generated and set to refresh the cookie, ensuring the client has an up-to-date token, especially if user-related data (like username) is encoded in it or if it's generally good practice after a profile change.

```javascript
// backend/src/controllers/auth.controller.js
export const updateProfile = async (req, res) => {
    try {
        const { profilePic, username } = req.body;
        const userId = req.user._id; // From protectRoute middleware
        let userToUpdate = await User.findById(userId);

        if (!userToUpdate) return res.status(404).json({ message: "User not found." });

        const fieldsToUpdate = {};
        let newUsername = username ? username.trim() : null;

        // Handle username update logic (validation, uniqueness check)
        if (newUsername && newUsername !== userToUpdate.username) {
            // ... validation and check for existing username logic ...
            fieldsToUpdate.username = newUsername;
        }

        // Handle profile picture update logic (upload to Cloudinary)
        if (profilePic) {
            const uploadResponse = await cloudinary.uploader.upload(profilePic);
            fieldsToUpdate.profilePic = uploadResponse.secure_url;
        }

        if (Object.keys(fieldsToUpdate).length === 0) {
            return res.status(400).json({ message: "No changes provided to update." });
        }

        const updatedUser = await User.findByIdAndUpdate(userId, { $set: fieldsToUpdate }, { new: true });
        generateToken(updatedUser._id, res); // Refresh JWT
        res.status(200).json(updatedUser);

    } catch (error) {
        console.error("Error in updateProfile controller", error.message);
        // ... error handling ...
        res.status(500).json({ message: "Internal Server Error while updating profile." });
    }
};
```
[View `updateProfile` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L210-L281)

### Check Username Availability (`checkUsernameAvailability`)

This endpoint allows clients to check if a desired username is available before a user attempts to update their profile or sign up. It validates the username's length and checks against existing usernames in the database, while also accounting for the current user's own username.

```javascript
// backend/src/controllers/auth.controller.js
export const checkUsernameAvailability = async (req, res) => {
    try {
        const { username } = req.params;
        const currentUserId = req.user._id; // Populated by protectRoute

        // ... validation for username length ...

        // Check if the username is the current user's existing username
        if (req.user.username === username) {
            return res.status(200).json({ available: true, message: "This is your current username." });
        }

        const existingUser = await User.findOne({ username: username });

        if (existingUser) {
            return res.status(200).json({ available: false, message: "Username is already taken." });
        }

        res.status(200).json({ available: true, message: "Username is available." });

    } catch (error) {
        console.error("Error in checkUsernameAvailability:", error.message);
        res.status(500).json({ available: false, message: "Error checking username availability." });
    }
};
```
[View `checkUsernameAvailability` on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L167-L207)

## Key Integration Points

*   **`passport.config.js`**: Central for all OAuth strategy definitions and user serialization/deserialization, ensuring `req.user` is consistently available across routes after authentication.
*   **`auth.middleware.js`**: The `protectRoute` middleware is paramount for securing API endpoints. It must be applied to any route that requires an authenticated user.
*   **`auth.controller.js`**: Contains all business logic for user interaction: registration, login, logout, profile updates, and OAuth callbacks. It coordinates with `passport.js`, `bcryptjs`, `jsonwebtoken`, and the `User` model.
*   **HTTP-only Cookies**: Crucial for securely storing JWTs on the client side, mitigating XSS risks. `sameSite: "strict"` helps against CSRF attacks, and `secure: true` ensures cookies are only sent over HTTPS in production.
*   **Error Handling**: Comprehensive error handling in controllers and middleware provides informative feedback to the client and logs server-side issues.

These components work in concert to provide a secure and flexible authentication and authorization system, supporting both traditional email/password and modern social login methods.