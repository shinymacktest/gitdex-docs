---
title: "Authentication and Authorization"
description: "Details on user authentication, session management, and access control mechanisms."
sidebar_position: 21
---

---
title: "Authentication and Authorization"
description: "Details on user authentication, session management, and access control mechanisms."
sidebar_position: 21
---

# Authentication and Authorization
<TOC />

This section details the robust user authentication, secure session management, and precise access control mechanisms implemented in the backend. It covers both traditional email/password authentication and modern Google OAuth integration, ensuring secure and flexible user access.

## System Purpose

The authentication and authorization system is designed to:
*   **Secure User Data:** Protect sensitive user information and ensure only authenticated and authorized users can access specific resources.
*   **Manage User Sessions:** Provide persistent and secure user sessions across the application, utilizing JWTs stored in HTTP-only cookies.
*   **Offer Flexible Authentication:** Support multiple authentication methods including email/password and Google OAuth for user convenience.
*   **Ensure Data Integrity:** Validate user input during registration and profile updates to maintain data quality.
*   **Control Access:** Implement middleware to restrict access to protected routes, ensuring only logged-in users can perform certain actions.
*   **Enhance User Experience:** Provide endpoints for checking authentication status and managing profiles, including username availability and profile picture updates.

## Architecture

The authentication and authorization architecture is built upon a MERN stack, primarily residing within the Node.js/Express backend, interacting with MongoDB for user storage. Frontend interactions trigger API calls, which are then processed by the backend.



```mermaid
graph TD
    A["Client (Frontend)"] --> B{Authentication Gateway};
    B --> |1. /api/auth/signup| C[Signup Controller];
    B --> |2. /api/auth/login| D[Login Controller];
    B --> |3. /api/auth/google| E[Google OAuth Init];
    B --> |4. /api/auth/google/callback| F[Google OAuth Callback];
    B --> |5. /api/auth/logout| G[Logout Controller];
    B --> |6. Protected Routes| H[Auth Middleware];
    B --> |7. /api/auth/check| I[CheckAuth Controller];
    B --> |8. /api/auth/username/check/:username| J[Check Username Availability];
    B --> |9. /api/auth/update-profile| K[Update Profile Controller];

    C --> L[User Model (MongoDB)];
    D --> L;
    E --> P[Google OAuth Service];
    F --> P;
    F --> L;
    G --> A;
    H --> L;
    H --> I;
    H --> J;
    H --> K;
    I --> A;
    J --> L;
    K --> L;
    K --> Q[Cloudinary (for profilePic)];

    C --> M[Bcrypt (Password Hashing)];
    D --> M;
    C --> N[JWT Generation];
    D --> N;
    F --> N;
    K --> N;
    H --> O[JWT Verification];

    N --> A[Set JWT Cookie];
    O --> A[Verify JWT Cookie];
```



**Workflow Overview:**
1.  **Client (Frontend)** initiates authentication requests.
2.  **Authentication Gateway** (`auth.route.js`) directs requests to appropriate controllers.
3.  **Signup/Login Controllers** (`auth.controller.js`) handle email/password registration and login, interacting with the `User` model, `bcrypt` for password management, and `JWT Generation` for session tokens.
4.  **Google OAuth** flow involves initiating authentication with `Google OAuth Service`, followed by a callback that processes user data and generates a JWT.
5.  **Auth Middleware** (`auth.middleware.js`) protects routes by `JWT Verification` from cookies, ensuring only authenticated users proceed.
6.  **Profile Management** and utility endpoints (`auth.controller.js`) like `checkUsernameAvailability` and `updateProfile` also interact with the `User` model, with `updateProfile` optionally using `Cloudinary` for image storage.
7.  **Logout Controller** clears the JWT cookie, ending the session.

## Technology Stack

| Layer/Component | Technology | Purpose |
| :-------------- | :--------- | :------ |
| **Authentication** | JSON Web Tokens (JWT) | Secure, stateless session management, stored in HTTP-only cookies. |
| **Password Hashing** | `bcryptjs` | One-way hashing of user passwords for storage, enhancing security. |
| **OAuth Integration** | `passport.js` | Middleware for handling Google OAuth 2.0 authentication strategy. |
| **User Model** | `mongoose` (MongoDB ODM) | Schema definition and interaction with MongoDB for user data storage. |
| **Image Storage** | `cloudinary` | Cloud-based solution for storing and serving user profile pictures. |
| **Request Handling** | `express.js` | Web application framework for routing and API endpoint management. |
| **Environment Variables** | `dotenv` | Secure management of sensitive configuration like API keys and secrets. |

## Features

### 1. User Registration (`signup`)

The `signup` controller handles new user registrations, including robust input validation and secure password hashing.

```javascript
// backend/src/controllers/auth.controller.js
export const signup = async (req, res) => {
    const {username, email, password} = req.body;
    try {
        if(!username || !email || !password) {
            return res.status(400).json({message: "Please fill in all fields."});
        }
        if (username.length < 3 || username.length > 20) {
            return res.status(400).json({ message: "Username must be between 3 and 20 characters." });
        }
        if (password.length < 6) {
            return res.status(400).json({message: "Password must be at least 6 characters."});
        }
        const user = await User.findOne({email});
        if (user) return res.status(400).json({message: "Email already exists."});
        
        const existingUserByUsername = await User.findOne({ username });
        if (existingUserByUsername) {
            return res.status(400).json({ message: "Username already exists. Please choose another." });
        }

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        const newUser = new User({
            username,
            email,
            password: hashedPassword,
            authProvider: 'email'
        });
        if(newUser){
            generateToken(newUser._id, res); // Generates and sets JWT cookie
            await newUser.save();

            res.status(201).json({
                _id: newUser._id,
                username: newUser.username,
                email: newUser.email,   
                profilePic: newUser.profilePic,
                authProvider: newUser.authProvider
            });
        } else {
            res.status(400).json({message: "Invalid user data."});
        }
    } catch (error) {
        console.log("Error in signup controller", error.message)
        res.status(500).json({message: "Something went wrong."});
    }
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L1-L50)

**Details:**
*   **Input Validation:** Ensures `username`, `email`, and `password` are provided and meet length requirements.
*   **Uniqueness Checks:** Verifies that both the `email` and `username` are unique to prevent duplicate accounts.
*   **Password Hashing:** Uses `bcrypt.genSalt(10)` to generate a salt and `bcrypt.hash` to hash the password, providing a strong defense against brute-force attacks. A `salt` round of 10 is a good balance between security and performance.
*   **JWT Generation:** Upon successful registration, a JSON Web Token is generated via `generateToken` (from `lib/utils.js`, not provided but inferred) and set as an HTTP-only cookie, establishing the user's session.
*   **Response:** Returns newly created user details (excluding password) and a `201 Created` status.

### 2. User Login (`login`)

The `login` controller authenticates existing users by verifying their credentials.

```javascript
// backend/src/controllers/auth.controller.js
export const login = async (req, res) => {
    const {email, password} = req.body;
    try {
        const user = await User.findOne({email});

        if(!user) {
            return res.status(400).json({message: "Invalid credentials."});
        }

        if(user.authProvider === 'google' && !user.password){
            return res.status(400).json({ message: "Please sign in with Google." });
        }

        const isPasswordCorrect = await bcrypt.compare(password, user.password);
        if(!isPasswordCorrect) {
            return res.status(400).json({message: "Invalid credentials."});
        }

        generateToken(user._id, res); // Generates and sets JWT cookie
        res.status(200).json({
            _id: user._id,
            username: user.username,
            email: user.email,
            profilePic: user.profilePic,
            authProvider: user.authProvider,
        });
    } catch (error) {
        console.log("Error in login controller", error.message);
        res.status(500).json({message: "Something went wrong."});
    }
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L52-L86)

**Details:**
*   **Credential Verification:** Finds the user by `email` and then uses `bcrypt.compare` to check if the provided `password` matches the stored hashed password.
*   **Provider Check:** Specifically handles cases where a user might try to log in with email/password if their account was initially created via Google OAuth, guiding them to use the correct method.
*   **JWT Issuance:** On successful authentication, a new JWT is issued and set as an HTTP-only cookie.
*   **Response:** Returns authenticated user details and a `200 OK` status.

### 3. Google OAuth 2.0 Integration

The application integrates with Google for third-party authentication using `passport.js` with the `passport-google-oauth20` strategy.

```javascript
// backend/src/lib/passport.config.js
import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import User from '../models/user.model.js'; 
import dotenv from 'dotenv';

dotenv.config(); 

export const configurePassport = () => {
    passport.use(new GoogleStrategy({
        clientID: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET,
        callbackURL: process.env.GOOGLE_CALLBACK_URL,
        scope: ['profile', 'email'] 
    },
    async (accessToken, refreshToken, profile, done) => {
        try {
            let user = await User.findOne({ googleId: profile.id });

            if (user) {
                return done(null, user); // User already exists, log in
            } else {
                let username = profile.displayName.replace(/\s+/g, '').toLowerCase() || `user${Date.now()}`;
                const existingUserByUsername = await User.findOne({ username });
                if (existingUserByUsername) {
                    username = `${username}${Date.now().toString().slice(-4)}`; // Make it more unique
                }
                if (username.length > 20) username = username.substring(0,20);

                const newUser = new User({
                    googleId: profile.id,
                    email: profile.emails && profile.emails[0] ? profile.emails[0].value : null,
                    username: username,
                    authProvider: 'google',
                });

                if (!newUser.email) {
                    return done(new Error("Email not provided by Google. Cannot create account."), null);
                }

                const existingUserByEmail = await User.findOne({ email: newUser.email });
                if (existingUserByEmail && existingUserByEmail.authProvider !== 'google') {
                    return done(null, false, { message: `An account with email ${newUser.email} already exists. Please sign in using your original method.` });
                }

                await newUser.save();
                return done(null, newUser);
            }
        } catch (error) {
            return done(error, null);
        }
    }));

    passport.serializeUser((user, done) => {
        done(null, user.id); 
    });

    passport.deserializeUser(async (id, done) => {
        try {
            const user = await User.findById(id);
            done(null, user); 
        } catch (error) {
            done(error, null);
        }
    });
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/lib/passport.config.js#L1-L77)

**Details:**
*   **GoogleStrategy:** Configured with `clientID`, `clientSecret`, `callbackURL`, and `scope` to request user `profile` and `email` from Google.
*   **Verification Callback:**
    *   Checks if a user with `googleId` already exists. If so, logs them in.
    *   If not, creates a new user, generating a unique `username` from `profile.displayName` and handling potential conflicts.
    *   Ensures an email is provided by Google; otherwise, account creation fails.
    *   Prevents creating a Google-linked account if an `email`-based account already exists with the same email, guiding the user to their original sign-in method.
    *   Persists the new user to the database and returns the user object.
*   **`serializeUser`/`deserializeUser`:** `passport.js` uses these functions to manage user sessions. `serializeUser` stores the user ID in the session, and `deserializeUser` retrieves the full user object from the database using that ID, attaching it to `req.user`.

```javascript
// backend/src/controllers/auth.controller.js
export const googleAuthCallback = async (req, res) => {
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
    try {
        if (!req.user) {
            return res.redirect(`${frontendUrl}/login?error=google_auth_failed`);
        }
        generateToken(req.user._id, res); // Generates and sets JWT cookie
        res.redirect(frontendUrl); // Redirects to frontend on success
    } catch (error) {
        console.error("Error in googleAuthCallback: ", error.message);
        res.redirect(`${frontendUrl}/login?error=google_auth_processing_error`);
    }
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L107-L123)

**Details:**
*   **Post-Authentication:** After successful Google authentication via `passport.authenticate`, this controller receives the authenticated user in `req.user`.
*   **JWT Generation:** A JWT is generated for the `req.user._id` and set as an HTTP-only cookie.
*   **Redirection:** The user is then redirected to the frontend application's home page or a login error page if authentication failed.

### 4. Route Protection (`protectRoute`)

A critical middleware `protectRoute` ensures that only authenticated users can access specific API endpoints.

```javascript
// backend/src/middleware/auth.middleware.js
import jwt from "jsonwebtoken"
import User from "../models/user.model.js"

export const protectRoute = async (req, res, next) => {
    try {
        const token = req.cookies.jwt;
        if(!token){
            return res.status(401).json({message: "Unauthorized - No Token Provided"});
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET)

        if(!decoded) {
            return res.status(401).json({message: "Unauthorized - Invalid Token"});
        }
        const user = await User.findById(decoded.userId).select("-password");

        if(!user) {
            return res.status(404).json({message: "User not found"});
        }
        req.user = user; // Attach user object to request for subsequent middleware/controllers

        next(); // Proceed to the next middleware/controller
    } catch (error) {
        console.log("Error in protectRoute middleware", error.message);
        res.status(500).json({message: "Internal Server Error"});
    }
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/middleware/auth.middleware.js#L1-L26)

**Details:**
*   **Token Retrieval:** Extracts the JWT from the `jwt` HTTP-only cookie.
*   **Token Verification:** Uses `jwt.verify` to validate the token's authenticity and expiration against `process.env.JWT_SECRET`.
*   **User Retrieval:** If valid, extracts `userId` from the decoded token and fetches the corresponding user from the database, excluding the password.
*   **Authorization:** Attaches the `user` object to `req.user`, making user information available to subsequent controllers.
*   **Error Handling:** Returns `401 Unauthorized` if no token, invalid token, or `404 Not Found` if the user associated with the token doesn't exist.

### 5. Profile Management (`updateProfile`)

Allows authenticated users to update their profile information, specifically `username` and `profilePic`.

```javascript
// backend/src/controllers/auth.controller.js
export const updateProfile = async (req, res) => {
    try {
        const { profilePic, username } = req.body; 
        const userId = req.user._id;
        let userToUpdate = await User.findById(userId);

        if (!userToUpdate) {
            return res.status(404).json({ message: "User not found." });
        }

        const fieldsToUpdate = {};
        let newUsername = username ? username.trim() : null;

        // Handle username update
        if (newUsername && newUsername !== userToUpdate.username) {
            if (newUsername.length < 3 || newUsername.length > 20) {
                return res.status(400).json({ message: "Username must be between 3 and 20 characters." });
            }
            const existingUserWithNewUsername = await User.findOne({ username: newUsername, _id: { $ne: userId } });
            if (existingUserWithNewUsername) {
                return res.status(400).json({ message: "This username is already taken by someone else." });
            }
            fieldsToUpdate.username = newUsername;
        }

        // Handle profile picture update
        if (profilePic) {
            const uploadResponse = await cloudinary.uploader.upload(profilePic);
            fieldsToUpdate.profilePic = uploadResponse.secure_url;
        }

        if (Object.keys(fieldsToUpdate).length === 0) {
            return res.status(400).json({ message: "No changes provided to update." });
        }

        const updatedUser = await User.findByIdAndUpdate(userId, { $set: fieldsToUpdate }, { new: true });

        if (!updatedUser) {
            return res.status(404).json({ message: "Failed to update user."});
        }
        
        generateToken(updatedUser._id, res); // Refresh JWT cookie to reflect potential username changes
        res.status(200).json(updatedUser);

    } catch (error) {
        console.error("Error in updateProfile controller", error.message);
        if (error.code === 11000 && error.keyValue && error.keyValue.username) {
            return res.status(400).json({ message: "This username is already taken." });
        }
        res.status(500).json({ message: "Internal Server Error while updating profile." });
    }
};
```
[View on GitHub](https://github.com/shinymack/Chat-App-MERN/blob/main/backend/src/controllers/auth.controller.js#L149-L215)

**Details:**
*   **Authentication Required:** This route is protected by `protectRoute`, ensuring only authenticated users can update their profiles.
*   **Username Update:** Validates the new username for length and uniqueness (excluding the current user's own existing username).
*   **Profile Picture Update:** If `profilePic` is provided (assumed to be a base64 string), it is uploaded to `Cloudinary`, and the secure URL is stored.
*   **Database Update:** Uses `findByIdAndUpdate` to atomically update the user document.
*   **Token Refresh:** A new JWT is generated and set to refresh the cookie, especially important if the username (which might be included in some token payloads or used for display in frontend) has changed.

## Key Integration Points

*   **API Gateway (`auth.route.js`):** All authentication and authorization requests are routed through `/api/auth`, defining clear entry points for various operations.
*   **User Model (`user.model.js` - not provided, but inferred):** Central to the system, it stores user credentials (hashed passwords, Google IDs), profile information, and `authProvider` flags, enabling a unified user management system across different authentication methods.
*   **JWT Utility (`lib/utils.js` - not provided, but inferred):** A `generateToken` utility is used consistently across `signup`, `login`, and `googleAuthCallback` to create and set HTTP-only JWT cookies, ensuring a standardized session management approach.
*   **Environment Variables (`dotenv`):** Critical for securing sensitive information like `JWT_SECRET`, `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET`, and `GOOGLE_CALLBACK_URL`, preventing hardcoding credentials and facilitating easy configuration management.
*   **Frontend-Backend Communication:** The use of HTTP-only cookies for JWTs effectively secures session tokens against XSS attacks, while the `googleAuthCallback` redirects ensure seamless user experience post-OAuth.

**Insights and Best Practices:**
*   **Scalability:** Storing JWTs in HTTP-only cookies ensures a stateless session, which is highly scalable as no server-side session store is required. User information is carried within the token itself, reducing database lookups for every request after initial authentication.
*   **Security:**
    *   **Bcrypt:** Essential for secure password storage. The `salt` rounds (10) provide good resistance against rainbow table attacks and brute-force attempts.
    *   **HTTP-only Cookies:** Protect JWTs from client-side JavaScript access, mitigating XSS risks.
    *   **JWT Expiration:** (Inferred from `generateToken`) JWTs should have a reasonable expiration time, and refresh token mechanisms can be implemented for long-lived sessions, though not explicitly shown for this specific project context.
    *   **Input Validation:** Comprehensive validation at the controller level prevents common injection attacks and ensures data integrity.
*   **User Experience:** Offering both traditional email/password and Google OAuth provides flexibility, catering to different user preferences. The `checkUsernameAvailability` endpoint is a small but impactful feature for improving user registration flow.

Next: [User and Friend Management](./2.2_user-and-friend-management.mdx)
```