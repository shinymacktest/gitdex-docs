---
title: "Frontend Components"
description: "Detailed breakdown of the UI components."
---

# Frontend Components

<TOC />

This document provides a detailed breakdown of the frontend components used in the chat application, focusing on their functionality, structure, and interaction.  The primary components are `ChatContainer`, `MessageInput`, and `Sidebar`. These components are built using React and leverage a state management system (details in the next section).

## ChatContainer Component

The `ChatContainer` component is responsible for rendering the main chat area, displaying messages, and handling the loading state.  It fetches and displays messages associated with the currently selected user.

**What it does:**

* Fetches messages for the selected user using `getMessages` from the chat store.
* Subscribes to real-time message updates using `subscribeToMessages`.
* Unsubscribes from updates when the component unmounts.
* Displays a loading skeleton while fetching messages.
* Renders individual messages, differentiating between sent and received messages using CSS classes (`chat-end`, `chat-start`).
* Automatically scrolls to the bottom when new messages arrive.

**Why this structure:**

The component's structure promotes clear separation of concerns.  Using effects for fetching and subscribing manages the lifecycle of data fetching and ensures efficient resource utilization. The conditional rendering based on `isMessagesLoading` provides a better user experience.

**How it works:**

The component uses `useEffect` hooks to manage side effects.  The first effect fetches messages and subscribes to updates, while the second ensures smooth scrolling.  The message rendering leverages data from the `useChatStore` hook.


```jsx
useEffect(() => {
    getMessages(selectedUser._id);
    subscribeToMessages();

    return () => unsubscribeFromMessages();
}, [selectedUser._id, getMessages, subscribeToMessages, unsubscribeFromMessages]);

useEffect(() => {
    if(messageEndRef.current && messages){
        messageEndRef.current.scrollIntoView({behaviour : "smooth"})
    }
}, [messages])
```

This code snippet shows the two `useEffect` hooks. The first fetches messages and manages subscriptions, while the second ensures the chat always scrolls to the bottom. The dependencies array ensures these effects run only when necessary.

```jsx
{messages.map((message) => (
    <div
        key={message._id}
        className={`chat ${message.senderId == authUser._id ? "chat-end": "chat-start"} `}
        ref={messageEndRef}
    >
        {/* ... message rendering logic ... */}
    </div>
))}
```

This part shows how messages are rendered. The `chat-end` and `chat-start` classes control the alignment of messages based on whether the current user sent them.  `messageEndRef` is used for the automatic scrolling functionality.

[Source](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/ChatContainer.jsx)


## MessageInput Component

The `MessageInput` component handles user input for sending messages, including text and image attachments.

**What it does:**

* Allows users to type messages.
* Allows users to upload images.
* Previews images before sending.
* Sends messages via the `sendMessage` function from the chat store.
* Handles error display using `react-hot-toast`.

**Why this structure:**

The component's structure separates input handling from sending logic, making the code more maintainable and testable. State management using `useState` keeps track of the message text and image preview.

**How it works:**

The component uses controlled inputs to manage the message text and an image preview. The `handleImageChange` function reads image data using a `FileReader`. The `handleSendMessage` function sends the message data to the backend.

```jsx
const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!text.trim() && !imagePreview) return;

    try {
        await sendMessage({
            text: text.trim(),
            image: imagePreview,
        });

        setText("");
        setImagePreview(null);
        // ...
    } catch (error) {
        console.error("Failed to send message", error);
    }
};
```

This code snippet demonstrates the `handleSendMessage` function. It prevents sending empty messages, sends data to the backend via `sendMessage`, clears the input fields, and handles potential errors.


[Source](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/MessageInput.jsx)

## Sidebar Component

The `Sidebar` component displays a list of friends, allowing users to select a chat partner.

**What it does:**

* Fetches the list of friends using `getFriends`.
* Displays the list of friends, indicating online status.
* Allows users to filter by online status.
* Highlights the currently selected user.

**Why this structure:**

The structure keeps the friend list separate from the chat area, improving UI organization and maintainability.  The use of a filter allows for a more focused user experience.


**How it works:**

The component fetches friends using `useEffect` and renders a list of buttons, each representing a friend. The `setSelectedUser` function updates the selected user in the store, triggering a change in the `ChatContainer`.


```jsx
{filteredUsers.map((user) => (
    <button
        key={user._id}
        onClick={() => setSelectedUser(user)}
        className={`sm:w-full w-[88vw] p-3 flex items-center gap-3 hover:bg-base-300 transition-colors
        ${
            selectedUser?._id === user._id
                ? "bg-base-300 ring-1 ring-base-300"
                : ""
        }`}
    >
        {/* ... user rendering logic ... */}
    </button>
))}
```

This snippet shows how each friend is rendered as a button. The class names dynamically highlight the selected user.

[Source](https://github.com/shinymack/Chat-App-MERN/blob/main/frontend/src/components/Sidebar.jsx)


## Component Hierarchy

````mermaid
graph TD
    A[App] --> B(ChatContainer);
    A --> C(Sidebar);
    B --> D[ChatHeader];
    B --> E[MessageInput];
    B --> F[MessageSkeleton];
    E --> G[Image Preview];
```

## Next: [Frontend State Management](./3.2_frontend_state_management.mdx)