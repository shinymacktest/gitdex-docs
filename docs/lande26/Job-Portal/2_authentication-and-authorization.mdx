---
title: "Authentication and Authorization"
description: "Mechanisms for user and employer authentication and access control."
sidebar_position: 2
---
# Authentication and Authorization

This section details the authentication and authorization mechanisms implemented in the Job Portal, covering user and employer registration, login, and protected route handling.

## User and Employer Registration

The system supports distinct registration processes for regular users and employers. Both processes involve data validation, password hashing, and the generation of JWT (JSON Web Token) for subsequent authentication.

### Employer Registration

Employers can register by providing a username, email, and password. The backend validates the input, hashes the password using bcrypt, and stores the employer's credentials. A JWT is generated upon successful registration, and a company profile is also initialized.

```javascript
// Backend/controllers/registeremp.js
const { EModel } = require("../models/user");
const bcrypt = require("bcrypt");
const joi = require("joi");
const jwt = require("jsonwebtoken");
const companyprofile = require("../models/companyprofile");

const registeremp = async (req, res, next) => {
  const { error: validationError } = validateEmployer(req.body);

  if (validationError) {
    return res
      .status(400)
      .json({ message: validationError.details[0].message });
  }

  const { username, email, password } = req.body;

  try {
    const formattedName = username.toLowerCase();
    const formattedEmail = email.toLowerCase();

    const existingEmployer = await EModel.findOne({ email: formattedEmail });
    if (existingEmployer) {
      return res.status(400).json({ message: "This user already exists" });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const newEmployer = new EModel({
      username: formattedName,
      email: formattedEmail,
      password: hashedPassword,
    });

    await newEmployer.save();
    const accessToken = jwt.sign(
      {
        username: newEmployer.formattedName,
        empId: newEmployer._id,
      },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );
    const newcomapany=new companyprofile({
      username:formattedName,
      email:formattedEmail,
    })
    await newcomapany.save();
    
    res.status(200).json({
      message: "Employer registered successfully",
      token: accessToken,
      username:newEmployer.username
    });
  } catch (err) {
    next(err);
  }
};

function validateEmployer(data) {
  const EModel = joi.object({
    username: joi.string().min(2).required(),
    email: joi.string().email().required(),
    password: joi.string().min(5).max(12).required(),
  });
  return EModel.validate(data);
}

module.exports = registeremp;
```

### User Registration

Regular users register with similar fields: username, email, and password. Input is validated, passwords are hashed, and a JWT is issued. Additional data for user profiles and assets are also initialized.

```javascript
// Backend/controllers/registeruser.js
const { UserModel } = require('../models/user');
const UserProfile = require('../models/userprofile');
const bcrypt = require('bcrypt');
const joi = require('joi');
const jwt = require('jsonwebtoken');
const UserAssets = require('../models/userassets');

const registeruser = async (req, res, next) => {
    const { error: validationError } = validateUser(req.body);

    if (validationError) {
        return res.status(400).json({ message: validationError.details[0].message });
    }

    const { username, email, password } = req.body;

    try {
        const formattedName = username.toLowerCase();
        const formattedEmail = email.toLowerCase();

        const existingUser = await UserModel.findOne({ email: formattedEmail });
        if (existingUser) {
            return res.status(400).json({ message: 'This user already exists' });
        }

        const hashedPassword = await bcrypt.hash(password, 10);

        const newUser = new UserModel({
            username: formattedName,
            email: formattedEmail,
            password: hashedPassword,
        });
        await newUser.save();
        const accessToken = jwt.sign(
            {
                username: formattedName,
                empId: newUser._id,
            },
            process.env.JWT_SECRET,
            { expiresIn: '7d' }
        );
        const newUserProfile = new UserProfile({
            username: formattedName,
            email:formattedEmail,
        });
        await newUserProfile.save();

        const newUserAssets = new UserAssets({
            username: formattedName,
            profilepicurl: "",
            savedjobs: []
        });
        await newUserAssets.save();

        res.status(200).json({ message: 'User registered successfully', token: accessToken,username:formattedName });
    } catch (err) {
        next(err);
    }
};

function validateUser(data) {
    const userSchema = joi.object({
        username: joi.string().min(2).required(),
        email: joi.string().email().required(),
        password: joi.string().min(5).max(12).required(),
    });
    return userSchema.validate(data);
}

module.exports = registeruser;
```

## User and Employer Login

The login process for both users and employers is similar. Upon receiving credentials, the system verifies them against the stored hashed passwords. A successful login results in the issuance of a JWT.

### Employer Login

```javascript
// Backend/controllers/loginemp.js
const { EModel } = require('../models/user');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const loginemp = async (req, res, next) => {
    const { email, password } = req.body;
    try {
        const formattedEmail = email.toLowerCase();

        const existingUser = await EModel.findOne({ email: formattedEmail });
        if (!existingUser) {
            return res.status(400).json({ message: "This user does not exist" });
        }

        const isPassmatch = await bcrypt.compare(password, existingUser.password);
        if (!isPassmatch) {
            return res.status(400).json({ message: "Incorrect password " });
        }
        const accessToken = jwt.sign(
            {
                username: existingUser.username,
                empId: existingUser._id,
            },
            process.env.JWT_SECRET,
            { expiresIn: "7d" }
        );

        res.status(200).json({ message: 'Login successfull', status: true, token: accessToken,username:existingUser.username });

    }
    catch (error) {
        next(error);
    }
}

module.exports = loginemp;
```

### User Login

```javascript
// Backend/controllers/loginuser.js
const { UserModel } = require('../models/user');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const loginuser = async (req, res, next) => {
    const { email, password } = req.body;
    try {
        const formattedEmail = email.toLowerCase();

        const existingEmployer = await UserModel.findOne({ email: formattedEmail });
        if (!existingEmployer) {
            return res.status(400).json({ message: "This user does not exist" });
        }

        const isPassmatch = await bcrypt.compare(password, existingEmployer.password);
        if (!isPassmatch) {
            return res.status(400).json({ message: "Incorrect password " });
        }
        const accessToken = jwt.sign(
            {
                name: existingEmployer.username,
                empId: existingEmployer._id,
            },
            process.env.JWT_SECRET,
            { expiresIn: "7d" }
        );
        res.status(200).json({ message: 'Login successfull', status: true, token: accessToken, username: existingEmployer.username });

    }
    catch (error) {
        next(error);
    }
}

module.exports = loginuser;
```

## Authentication Middleware

A `requireAuth` middleware is implemented to protect routes that require authenticated access. This middleware intercepts incoming requests, extracts the JWT from the Authorization header, verifies its authenticity and expiration, and then proceeds to the next middleware or route handler.

```javascript
// Backend/middlewares/requireauth.js
const jwt = require('jsonwebtoken');
const { UserModel } = require('../models/user'); // Assuming UserModel is also used for employers

const requireAuth = async (req, res, next) => {
    const { authorization } = req.headers;

    if (!authorization) {
        return res.status(401).json({ message: "You must be logged in" });
    }

    let token = authorization.split(" ")[1];

    token = token.replace(/^"|"$/g, '');

    try {
        const { empId } = jwt.verify(token, process.env.JWT_SECRET);

        // Assuming _id can represent both user and employer IDs
        const user = await UserModel.findOne({ _id: empId }).select('_id');

        if (!user) {
            return res.status(401).json({ message: "User not found" });
        }

        req.user = user; // Attach user ID to request object
        next();
    } catch (err) {
        console.error("JWT Verification Error:", err);
        return res.status(401).json({ message: "Request is not authorized" });
    }
};

module.exports = requireAuth;
```

## Frontend Authentication State Management

The frontend utilizes React's `createContext` and `useReducer` hooks to manage authentication state. The `AuthContext` stores the user's authentication status and provides a mechanism to update it upon login or logout. The `useEffect` hook initializes the authentication state by checking `localStorage` for a stored JWT.

```tsx
// Frontend/src/context/authcontext.jsx
import React, { useReducer,useEffect,createContext } from "react";

export const  AuthContext=createContext()

export const authReducer=(state,action)=>{
      switch(action.type){
        case 'LOGIN':
            return{
                user:action.payload
            };
        case 'LOGOUT':
            return{
                user:null
            }
            default:
                return state
      }
}
export const AuthContextProvider=({children})=>{
      const [state,dispatch]=useReducer(authReducer,{
               user:null
      })
      useEffect(()=>{
        const user=localStorage.getItem('accessToken')
        if(user){
            dispatch({type:'LOGIN',payload:user})
        }
      },[])
      return(
        <AuthContext.Provider value={{...state,dispatch}}>
            {children}
        </AuthContext.Provider>
      )
}
```

## Key Takeaways

*   **Dual Registration**: The system supports separate registration for regular users and employers, ensuring tailored data handling.
*   **JWT-Based Authentication**: JSON Web Tokens are used for session management and authentication after successful login.
*   **Password Security**: Bcrypt is employed for secure password hashing to protect user credentials.
*   **Protected Routes**: A middleware (`requireAuth`) enforces authentication for sensitive API endpoints.
*   **Frontend State Management**: React Context API and useReducer manage the global authentication state on the frontend, with persistence via `localStorage`.